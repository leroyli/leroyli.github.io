<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LLDB 打印变量指令</title>
    <url>/2020/03/08/LLDB-po/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>lldb提供了3种指令来打印变量，分别是po、p、v、今天我们就来看看这3种指令的实现方式和区别。<br><a href="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/LLDB_PO.md" target="_blank" rel="noopener">本文连接</a></p>
<a id="more"></a>
<h3 id="po指令"><a href="#po指令" class="headerlink" title="po指令"></a>po指令</h3><p><img src="https://s2.ax1x.com/2020/03/08/3xbe4P.jpg" alt="429_lldb_beyond_pox"></p>
<p>po指令可以看成是打印变量的固定指令，当我们使用po的时候，像上图一样我们得到的是文本形式的对象描述。po不仅仅能打印变量，还能像下图一样拿到对象的名字并计算名字的大写版本。</p>
<p><img src="https://s2.ax1x.com/2020/03/08/3xb3Hs.jpg" alt="429_lldb_beyond_pos"></p>
<p>事实上它可以计算任何表达式，其实po只是一个expression表达式的别名，你可以用command alias指令实现自定义的po指令</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_pocc.jpg" alt="429_lldb_beyond_pocc"></p>
<p>下面我们来看看po的底层是如何工作的</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_po.jpg" alt="429_lldb_beyond_po"></p>
<p>为了提供完整描述，首先它会根据你输入的表达式生成一段代码，然后会在debug程序里编译并执行这段代码来计算表达式的结果，LLDB拿到结果之后会生成另一短代码来格式化结果输出字符串</p>
<h3 id="p指令"><a href="#p指令" class="headerlink" title="p指令"></a>p指令</h3><p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_por.jpg" alt="429_lldb_beyond_por"></p>
<p>p指令和po指令打印出来的格式有点不一样，但是内容是一样的。而且返回值被起名为$R0，这是LLDB的一个约定，每个表达式的结果会被赋予一个递增的名字。像$R0, $R1,并且这个被赋予的名字可以用在稍后的表达式中。你可以像使用其他变量一样使用$R0</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_poRRQ.jpg" alt="429_lldb_beyond_poRRQ"></p>
<p>下面让我们看看p指令在后台是如何运行的</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_p.jpg" alt="429_lldb_beyond_p"></p>
<p>事实上p指令底层的第一部分跟po指令是一样的，会先计算计算表达式的结果，一旦拿到结果LLDB会对结果执行动态类型解析。至于什么是动态类型解析，可以用一个例子说明一下</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_poddd.jpg" alt="429_lldb_beyond_poddd"></p>
<p>在上面的例子中，Trip遵守了Activity协议，在swift中源码中的静态类型和运行时的动态类型可以是不一样的，像上面的例子一样，可以用协议的类型去声明cruise对象。cruise的静态类型是Acitivity，但是运行时类型是Trip，如果我们打印cruise我们得到的也是Trip类型，因为LLDB会根据元数据展示给定变量的精确类型。这就是动态类型解析</p>
<p>在p指令下，动态类型解析只会对表达式的结果执行，当我们想打印cruise的name的时候，这时cruise的类型是Activity，没有name属性，所以就会出错，如果要消除错误可以把对象转化为其动态类型</p>
<p>当对结果执行完动态类型解析，LLDB会把解析的结果传递给格式化子系统来打印出可读的字符串</p>
<p>如果你想之后没有格式化的时候数据是什么样，可以使用 expression –raw –指令查看</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_poggg.jpg" alt="429_lldb_beyond_poggg"></p>
<h3 id="v指令"><a href="#v指令" class="headerlink" title="v指令"></a>v指令</h3><p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_vvvv.jpg" alt=""></p>
<p>v指令的输出也是依赖LLDB的格式化子系统，v指令是在xcode10才引入的，不像其他两个指令，v不会编译和执行代码，所以v的执行更快速。v指令有自己的语法，而且它的语法可以跟你在调试的程序的语言的语法不一样。它可以用.和下标去获取变量。</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_pojjjjj.jpg" alt="429_lldb_beyond_pojjjjj"></p>
<p>v指令不能计算表达式，因为计算需要执行代码，如果要执行计算表达式可以使用po或者p</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_vvvd.jpg" alt="429_lldb_beyond_vvvd"></p>
<p>v根据程序描述去在内存种定位变量的位置，然后从内存中读取变量，然后对结果执行动态类型解析，当用于想访问子字段，它就对每一个子字段重复执行动态类型解析，一旦完成，就会把结果移交给格式化子系统。</p>
<p>v可能会执行多次动态类型解析，但是格式化只有一次，只是在最后才格式化</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>下面是三种指令的对比</p>
<p><img src="https://github.com/leroyli/GitPages/blob/master/posts/lldb_po/images/lldb_po/429_lldb_beyond_pocccc.jpg" alt="429_lldb_beyond_pocccc"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://developer.apple.com/videos/play/wwdc2019/429/" target="_blank" rel="noopener">WWDC 2018.LLDB: Beyond “po”</a></p>
]]></content>
      <tags>
        <tag>LLDB</tag>
        <tag>po指令</tag>
        <tag>p指令</tag>
        <tag>v指令</tag>
        <tag>debug</tag>
        <tag>调试</tag>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 内存对齐</title>
    <url>/2020/03/05/iOS-Memory-layout/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k（通常它为4或8）的倍数，这就是所谓的内存对齐</p>
<a id="more"></a>
<h3 id="OC对象的内存占用"><a href="#OC对象的内存占用" class="headerlink" title="OC对象的内存占用"></a>OC对象的内存占用</h3><p>我们先来看看OC的对象所占用的内存<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NSObject *obj = [[NSObject alloc] init];</span><br><span class="line">NSLog(@&quot;实际占用： class_getInstanceSize = %zd&quot;, class_getInstanceSize([NSObject class]));</span><br><span class="line">NSLog(@&quot;系统分配：malloc_size = %zd&quot;, malloc_size((__bridge const void *)(obj)));</span><br><span class="line">NSLog(@&quot;NSObject类型占用：sizeOf = %zd&quot;, sizeof(obj));</span><br></pre></td></tr></table></figure></p>
<p>打印结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实际占用： class_getInstanceSize = 8</span><br><span class="line">系统分配：malloc_size = 16</span><br><span class="line">NSObject类型占用：sizeOf = 8</span><br></pre></td></tr></table></figure></p>
<p>可以看到NSObject实际占用了8字节，而系统分配了16字节。<br>这个可以从<a href="[https://opensource.apple.com/tarballs/objc4/](https://opensource.apple.com/tarballs/objc4/">源码</a><br>中看一看,我下载是objc4-779<br>在NSObject.mm中查看<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Replaced by ObjectAlloc</span></span><br><span class="line">+ (<span class="keyword">id</span>)allocWithZone:(<span class="keyword">struct</span> _NSZone *)zone &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAllocWithZone(<span class="keyword">self</span>, (malloc_zone_t *)zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后去看<code>_objc_rootAllocWithZone</code>的实现，在objc-runtime-new.mm中<br><figure class="highlight sqf"><table><tr><td class="code"><pre><span class="line">NEVER_INLINE</span><br><span class="line">id</span><br><span class="line"><span class="variable">_objc_rootAllocWithZone</span>(Class cls, malloc_zone_t *zone <span class="variable">__unused</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// allocWithZone under __OBJC2__ ignores the zone parameter</span></span><br><span class="line">    return <span class="variable">_class_createInstanceFromZone</span>(cls, <span class="number">0</span>, <span class="literal">nil</span>,</span><br><span class="line">                                         OBJECT_CONSTRUCT_CALL_BADALLOC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着看<code>_class-createInstanceFromZone</code>的实现<br><figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>class_createInstance</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>fixme</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Locking: none</span></span></span><br><span class="line"><span class="comment"><span class="markdown">*</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>Note: this function has been carefully written </span>so<span class="markdown"> that </span>the<span class="markdown"> fastpath</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="bullet">* </span>takes no branch.</span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>/</span></span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE id</span><br><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, <span class="keyword">void</span> *zone,</span><br><span class="line">                              <span class="built_in">int</span> construct_flags = OBJECT_CONSTRUCT_NONE,</span><br><span class="line">                              <span class="built_in">bool</span> cxxConstruct = <span class="keyword">true</span>,</span><br><span class="line">                              size_t *outAllocatedSize = nil)</span><br><span class="line">&#123;</span><br><span class="line">    ASSERT(cls-&gt;isRealized());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read class's info bits all at once for performance</span></span><br><span class="line">    <span class="built_in">bool</span> hasCxxCtor = cxxConstruct &amp;&amp; cls-&gt;hasCxxCtor();</span><br><span class="line">    <span class="built_in">bool</span> hasCxxDtor = cls-&gt;hasCxxDtor();</span><br><span class="line">    <span class="built_in">bool</span> fast = cls-&gt;canAllocNonpointer();</span><br><span class="line">    size_t size;</span><br><span class="line"></span><br><span class="line">    size = cls-&gt;instanceSize(extraBytes);</span><br><span class="line">    <span class="keyword">if</span> (outAllocatedSize) *outAllocatedSize = size;</span><br><span class="line"></span><br><span class="line">    id obj;</span><br><span class="line">    <span class="keyword">if</span> (zone) &#123;</span><br><span class="line">        obj = (id)malloc_zone_calloc((malloc_zone_t *)zone, <span class="number">1</span>, size);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        obj = (id)calloc(<span class="number">1</span>, size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(!obj)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (construct_flags &amp; OBJECT_CONSTRUCT_CALL_BADALLOC) &#123;</span><br><span class="line">            <span class="keyword">return</span> _objc_callBadAllocHandler(cls);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!zone &amp;&amp; fast) &#123;</span><br><span class="line">        obj-&gt;initInstanceIsa(cls, hasCxxDtor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Use raw pointer isa on the assumption that they might be</span></span><br><span class="line">        <span class="comment">// doing something weird with the zone or RR.</span></span><br><span class="line">        obj-&gt;initIsa(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!hasCxxCtor)) &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    construct_flags |= OBJECT_CONSTRUCT_FREE_ONFAILURE;</span><br><span class="line">    <span class="keyword">return</span> object_cxxConstructFromClass(obj, cls, construct_flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再看<code>size = cls-&gt;instanceSize(extraBytes)</code>的实现</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">size_t instanceSize(size_t extraBytes) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="built_in">if</span> (fastpath(cache.hasFastInstanceSize(extraBytes))) &#123;</span><br><span class="line">            <span class="built_in">return</span> cache.fastInstanceSize(extraBytes);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size_t <span class="built_in">size</span> = alignedInstanceSize() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes.</span></span><br><span class="line">        <span class="built_in">if</span> (<span class="built_in">size</span> &lt; <span class="number">16</span>) <span class="built_in">size</span> = <span class="number">16</span>;</span><br><span class="line">        <span class="built_in">return</span> <span class="built_in">size</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>到这里就能看到当实例对象不足16个字节，系统会分配给16个字节<br>所以我们可以得出结论<br>在64位架构下， 系统分配了16个字节给NSObject对象(通过malloc_size函数获得)；<br>但NSObject对象内部只使用了8个字节的空间（可以通过class_getInstanceSize函数获得）。</p>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>内存对齐的规则</p>
<ul>
<li><strong>结构体变量的首地址是其最长基本类型成员的整数倍；</strong></li>
<li><strong>结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如不满足，对前一个成员填充字节以满足；</strong></li>
<li><strong>结构体的总大小为结构体最大基本类型成员变量大小的整数倍；</strong></li>
<li><strong>结构体中的成员变量都是分配在连续的内存空间中。</strong></li>
</ul>
<p>下面我们创建一个OC类来验证一下<br><figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line"><span class="symbol">@interface</span> MemoryObject : NSObject &#123;</span><br><span class="line">    <span class="built_in">int</span> _age<span class="comment">;</span></span><br><span class="line">    NSString *_name<span class="comment">;</span></span><br><span class="line">    <span class="built_in">int</span> _height<span class="comment">;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//<span class="symbol">@property</span> (nonatomic, <span class="built_in">assign</span>) <span class="built_in">int</span> age<span class="comment">;</span></span><br><span class="line">//<span class="symbol">@property</span> (nonatomic, copy) NSString *name<span class="comment">;</span></span><br><span class="line">//<span class="symbol">@property</span> (nonatomic, <span class="built_in">assign</span>) <span class="built_in">int</span> height<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="symbol">@end</span></span><br></pre></td></tr></table></figure></p>
<p>打印一下内存<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">MemoryObject *m = [[MemoryObject alloc] init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class_getInstanceSize = %zd"</span>, class_getInstanceSize([MemoryObject <span class="keyword">class</span>]));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"malloc_size = %zd"</span>, malloc_size((__bridge <span class="keyword">const</span> <span class="keyword">void</span> *)(m)));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"sizeOf = %zd"</span>, <span class="keyword">sizeof</span>(m));</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">class_getInstanceSize</span> = <span class="number">32</span></span><br><span class="line"><span class="attr">malloc_size</span> = <span class="number">32</span></span><br><span class="line"><span class="attr">sizeOf</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>我们把MemoryObject转成C++代码看下<br><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">xcrun -sdk iphonesimulator clang -<span class="built_in">rewrite</span>-objc MemoryObject.m</span><br></pre></td></tr></table></figure></p>
<p>在C++代码中我们可以看到MemoryObject的结构<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MemoryObject_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>; <span class="comment">// 指针占用8个字节</span></span><br><span class="line">	<span class="keyword">int</span> _age;  <span class="comment">//4</span></span><br><span class="line">	<span class="built_in">NSString</span> *_name;  <span class="comment">//8</span></span><br><span class="line">	<span class="keyword">int</span> _height;  <span class="comment">//4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果没有内存对齐的话，内存占用应该是8+4+8+4 = 24个字节，现在根据内存对齐的规则（在结构体中，总大小为结构体对最大成员大小的整数倍，如不满足，最后填充字节以满足，可分配的最小内存是结构体中内存占用最大的成员变量的大小。）由于需要满足8的整数倍，所以最后填充字节分配32个字节<br><img src="https://i.loli.net/2020/03/06/4OBFWdZw2Hkpay9.png" alt="image.png"><br>结构体中成员变量的内存都是连续分配，由于_age只有4字节，按照内存对齐规则需要分配8个字节，而_height在最后也会因为内存对齐填充成8字节</p>
<p>而系统实际分配了32个字节，因为之前看源码，系统每次至少分配16个字节，这里的32是16的整数倍。<br>如果我们调整一下顺序<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MemoryObject</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">    <span class="keyword">int</span> _height;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对应的C++代码<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MemoryObject_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">	<span class="keyword">int</span> _age;</span><br><span class="line">	<span class="keyword">int</span> _height;</span><br><span class="line">	<span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>再次输出内存大小<br><figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="attr">class_getInstanceSize</span> = <span class="number">24</span></span><br><span class="line"><span class="attr">malloc_size</span> = <span class="number">32</span></span><br><span class="line"><span class="attr">sizeOf</span> = <span class="number">8</span></span><br></pre></td></tr></table></figure></p>
<p>内存分配应该是这样的了<br><img src="https://i.loli.net/2020/03/06/y5i9LnklaFweNIX.png" alt="image.png"><br>按照内存对齐规则，_age和_height加起来正好是8字节，不用系统填充，所以内存整个结构体占用24个字节，而系统需要满足16的倍数，还是32个字节。<br>所以成员变量的顺序是可以影响内存分配的<br>不过如果我们代码里用property声明的话<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">int</span> height;</span><br></pre></td></tr></table></figure></p>
<p>对应的C++代码是这样的<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> MemoryObject_IMPL &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="built_in">NSObject_IMPL</span> <span class="built_in">NSObject_IVARS</span>;</span><br><span class="line">	<span class="keyword">int</span> _age;</span><br><span class="line">	<span class="keyword">int</span> _height;</span><br><span class="line">	<span class="built_in">NSString</span> * _Nonnull _name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>顺序被调整过了，而且实际内存占用也是24个字节，可见使用property的时候苹果是做了这方面的优化的.</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="[https://zhuanlan.zhihu.com/p/98432137](https://zhuanlan.zhihu.com/p/98432137">关于NSObject对象的内存布局，看我就够了！</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>内存对齐</tag>
        <tag>源码</tag>
        <tag>NSObject</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向 Hopper</title>
    <url>/2020/03/04/iOSRE-Hopper/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iOS逆向中使用Hopper可以帮助我们分析目标APP的方法地址来实现动态调试，本文只是简单介绍一个Hopper的基本用法</p>
<a id="more"></a>
<h3 id="下载Hopper"><a href="#下载Hopper" class="headerlink" title="下载Hopper"></a>下载Hopper</h3><p>Hopper目前在最新的Mac系统上没有破解版，每次可以试用半小时，不过对于一般的分析也是够用了，这里贴一下Hopper的官网<a href="[https://www.hopperapp.com/](https://www.hopperapp.com/">Hopper</a><br>)</p>
<h3 id="分析目标APP"><a href="#分析目标APP" class="headerlink" title="分析目标APP"></a>分析目标APP</h3><p>这里主要是用自己新建的Demo用来分析，我Demo里就写了两个方法<br><img src="https://i.loli.net/2020/03/05/xJpQIBv4FKS6dNk.png" alt="image.png"></p>
<p>工程编译之后把.app文件拖到Hopper的窗口<br><img src="https://i.loli.net/2020/03/05/N6T3UKcZCRkpWn9.png" alt="image.png"><br>然后点击OK就行了<br><img src="https://i.loli.net/2020/03/05/stZj4pJNiFAUoIC.png" alt="hopper_add"></p>
<p>然后就可以进行分析了，我首先是在viewdidload里加了断点<br><img src="https://i.loli.net/2020/03/05/nWtBYwqOZuHLTCD.png" alt="b_viewdidload"><br>可以先用image list 打印文件的基地址，由于iOS的ASLR特性，需要用基地址来计算其他地址，上图第一条就是可执行文件加载的基地址<br><img src="https://i.loli.net/2020/03/05/fxrgQCOFdElw5BP.png" alt="image.png"></p>
<p>上图右边Hopper选中的部分是say方法的地址，不过这里自己新建的工程拉到Hopper里面Hopper也有一个基地址0x100000000<br>可以在控制台用<code>p/x</code>指令计算一下say方法的实际地址，计算方法是（可执行文件的基地址+Hopper中方法的偏移-Hoper加载的基地址），计算出结果后用<code>b</code>指令下断点，可以看到已经对say方法下了断点了，这时候让程序继续执行就会断到say方法了<br><img src="https://i.loli.net/2020/03/05/f8cMtChE2kAsFB5.png" alt="截屏2020-03-04下午5.02.28.png"></p>
<p>Hopper展示的都是汇编，我们也可以让xcode展示汇编，<img src="https://i.loli.net/2020/03/05/RNFwk6YC1vVEZ5h.png" alt="xcode_dis"><br>选中Always Show Disassembly之后就可以看到汇编代码了<br><img src="https://i.loli.net/2020/03/05/AK32TUL1m4JMsjy.png" alt="xcode_show_dis"><br>Xcode的汇编代码和Hopper的汇编代码相差的就是基地址了</p>
<h3 id="Hopper和MachOView"><a href="#Hopper和MachOView" class="headerlink" title="Hopper和MachOView"></a>Hopper和MachOView</h3><p>MachO文件是iOS的可执行文件，里面的地址也可以跟Hopper反汇编出来的对应<br><img src="https://i.loli.net/2020/03/05/pewvP4QmWAGBrgC.png" alt="截屏2020-03-04下午5.10.07.png"><br><img src="https://i.loli.net/2020/03/05/M4Su1t2Qga6IEh9.png" alt="截屏2020-03-04下午5.15.02.png"><br>Hopper还有很多用法，我这里只是做个基本的介绍。我是逆向初学者，如果文中有什么不对的地方，欢迎各位提出宝贵意见。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>Hopper</tag>
        <tag>MachO</tag>
        <tag>MachOView</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向 Reveal</title>
    <url>/2020/03/04/iOSRE-Reveal/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>逆向分析的时候可以用Reveal动态分析目标APP的UI界面来帮助我们更快的找到我们想要分析的位置，本文主要介绍如何让越狱设备能到成功连接Reveal并进行分析</p>
<a id="more"></a>
<h3 id="越狱设备Reveal2Loader"><a href="#越狱设备Reveal2Loader" class="headerlink" title="越狱设备Reveal2Loader"></a>越狱设备Reveal2Loader</h3><p>通过Cydia安装Reveal2Loader<br><img src="https://i.loli.net/2020/03/05/iRLJBTvNxcFrjyO.jpg" alt="WechatIMG52.jpeg"><br>安装之后可以设置对哪个APP开启reveal调试<br><img src="https://i.loli.net/2020/03/05/GI8NmhTrHzScMWK.jpg" alt="WechatIMG54.jpeg"><br><img src="https://i.loli.net/2020/03/05/JLv7ckFEUQ8mKfM.jpg" alt="WechatIMG53.jpeg"></p>
<p>开启某个APP后要重启springboard</p>
<h3 id="Mac安装Reveal"><a href="#Mac安装Reveal" class="headerlink" title="Mac安装Reveal"></a>Mac安装Reveal</h3><p>去<a href="[https://revealapp.com/](https://revealapp.com/">Reveal</a>官网下载。可以填写邮件获得14天的试用</p>
<h3 id="复制Mac上framework到越狱设备"><a href="#复制Mac上framework到越狱设备" class="headerlink" title="复制Mac上framework到越狱设备"></a>复制Mac上framework到越狱设备</h3><p>执行<code>scp -r /Users/[your dir]/Library/Application\ Support/Reveal/RevealServer/iOS/RevealServer.framework root@172.20.10.10:/Library/Frameworks</code>命令把Mac上的reveal framework复制到越狱设备</p>
<p>然后就可以调试目标APP了，下图是微信的UI界面<br><img src="https://i.loli.net/2020/03/05/OQwirzAMak9E452.png" alt="截屏2020-03-04下午4.02.43.png"></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>Reveal</tag>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS逆向 lldb动态调试</title>
    <url>/2020/03/04/iOSRE-lldb/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>使用 lldb 调试需要准备 debugserver。使用 OSX 中的 lldb 远程连接 iOS 上的 debugserver，由 debugserver 作为 lldb 和 iOS 的中转，执行命令和返回结果。在默认情况下，iOS 上并没有安装 debugserver，只有在设备连接过一次 Xcode，安装了开发者插件后，debugserver 才会被 Xcode 安装到iOS的/Developer/usr/bin/目录下。</p>
<a id="more"></a>
<h3 id="重签名debugserver"><a href="#重签名debugserver" class="headerlink" title="重签名debugserver"></a>重签名debugserver</h3><p>在iOS11越狱之前，需要对debugserver进行重签名，在iOS11上可以直接使用/Developer/usr/bin/debugserver，或者直接用 Xcode 对iOS上的app进行调试。iOS11之前用Xcode调试需要对app进行重签名，而iOS11之后不需要重签名app也能调试了。</p>
<p>iOS11之前重签名debugserver步骤：</p>
<p>1.拷贝debugserver到本地计算机中：<code>scp root@iOSDeviceIP:/Developer/usr/bin/debugserver ~/debugserver</code>。</p>
<p>2.然后用ldid添加权限。由于ldid不支持fat二进制文件，所以要给debugserver瘦身，通过lipo指定要支持的指令类型，例如：<code>lipo -thin arm64 ~/debugserver -output ~/debugserver</code>。</p>
<p>3.给debugserver添加task_for_pid权限，保存以下内容为ent.xml文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.springboard.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>task_for_pid-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>run-unsigned-code<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>然后执行以下命令添加权限：<code>ldid -Sent.xml debugserver</code></p>
<p>4.给debugserver重新签名，保存以下内容为entitlements.plist文件：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"> <span class="meta">&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/ PropertyList-1.0.dtd"&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">"1.0"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">key</span>&gt;</span>com.apple.springboard.debugapplications<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">key</span>&gt;</span>run-unsigned-code<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">key</span>&gt;</span>get-task-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">key</span>&gt;</span>task_for_pid-allow<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dict</span>&gt;</span> </span><br><span class="line"> <span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>复制代码<br>然后运行以下命令给的debugserver签名：<code>codesign -s - --entitlements entitlements.plist -f debugserver</code></p>
<p>5.重新拷贝debugserver回手机中：<code>scp ~/debugserver root@iOSDeviceIP:/usr/bin/debugserver</code></p>
<p>6.第一次使用debugserver时需要为其添加可执行权限：<code>chmod +x /usr/bin/debugserver</code></p>
<h3 id="lldb调试"><a href="#lldb调试" class="headerlink" title="lldb调试"></a>lldb调试</h3><p>准备好debugserver后，就可以调试任意第三方app了。</p>
<ol>
<li><p>SSH到iOS，使用debugserver来attach一个进程，要查看当前正在运行的进程，使用<strong>ps -e</strong>命令。比如我们要attach的进程号为 693，我们可以输入如下命令：<code>debugserver *:1234 -a 693</code></p>
</li>
<li><p>iOS11上<code>debugserver *:1234</code>中的<code>*:1234</code>要替换成<code>localhost:1234</code>。如果用的是Electra越狱，命令变成<code>/Developer/usr/bin/debugserver localhost:1234 -a 693</code>，如果用的是<a href="https://www.abcydia.com/read-16031.html" target="_blank" rel="noopener">unc0ver</a>越狱，则是<code>debugserver localhost:1234 -a 693</code>。同理，下文中的对应命令也要相应的替换</p>
</li>
<li><p>如果要用debugserver启动app，而不是附加到已经启动的app，则使用<code>debugserver *:1234 &lt;app二进制文件路径&gt;</code>，例如<code>debugserver *:1234 /var/containers/Bundle/Application/107F3307-2900-4720-B9BA-0C7792D89DF2/APP_TO_DEBUG.app/APP_TO_DEBUG</code></p>
</li>
<li><p>Mac端打开终端，输入lldb，回车，进入lldb界面，使用<code>process connect</code>命令连接客户端。 用WiFi连接到iOS设备时：<code>process connect connect://iOSDeviceIP:1234</code>。</p>
</li>
</ol>
<p>如果要用usbmux连接，则先使用<code>iproxy 1234 1234</code>进行一次端口转发，再使用<code>process connect connect://localhost:1234</code>，即可用USB连接到iOS设备。</p>
<p>回车后需要等待几分钟，时间有点久。</p>
<p>连接成功后，即可用lldb命令进行调试。</p>
<p><strong>SSH链接</strong></p>
<p><code>iproxy 2222 22</code>  端口转发</p>
<p><code>ssh -p 2222 root@127.0.0.1</code>   连接设备</p>
<p><strong>找到要调试的进程进行调试</strong></p>
<p><code>ps -e</code>   查看进程</p>
<p><code>debugserver 127.0.0.1:1234 -a 693</code>   attach进程</p>
<p><code>iproxy 1234 1234</code>进行一次端口转发</p>
<p><code>process connect connect://127.0.0.1:1234</code>  在lldb里执行</p>
<p>下图是调试微信的例子，lldb附加成功之后就可以根据地址使用<code>b</code>(地址加到b指令之后)指令下断点，地址可以根据hopper分析获取<br><img src="https://i.loli.net/2020/03/05/Obl82xfwrvcRNuh.png" alt="截屏2020-03-04下午2.32.14.png"></p>
<p>下图是使用hopper分析喜马拉雅播放方法的地址，然后使用lldb下断点<br><img src="https://i.loli.net/2020/03/05/agibCcmJ5whIHuM.png" alt="image.png"></p>
<h3 id="lldb常用命令"><a href="#lldb常用命令" class="headerlink" title="lldb常用命令"></a>lldb常用命令</h3><p>列出所有断点：<code>breakpoint list, br li</code><br>打开、关闭某个断点：<code>breakpoint enable, breakpoint disable, br dis, br del</code><br>打印参数：<code>frame variable, fr v</code><br>打印方法名和行数：<code>frame info</code><br>打印寄存器的值：<code>register read</code><br>修改寄存器的值：<code>register write rax 123</code><br>列出文件加载基地址：<code>image list</code><br>执行地址的加减运算：<code>p/x</code></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="[https://juejin.im/post/5d2b7d3f6fb9a07ebb0562d6](https://juejin.im/post/5d2b7d3f6fb9a07ebb0562d6">iOS 逆向指南：动态分析</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
        <tag>动态调试</tag>
        <tag>lldb</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 虚拟内存</title>
    <url>/2020/03/04/iOS-VM-Region/</url>
    <content><![CDATA[<h4 id="虚拟内存简介"><a href="#虚拟内存简介" class="headerlink" title="虚拟内存简介"></a>虚拟内存简介</h4><p>什么是VM Regions呢？要知道这个首先要了解什么是虚拟内存。当我们向系统申请内存时，系统并不会给你返回物理内存的地址，而是给你一个虚拟内存地址。每个进程都拥有相同大小的虚拟地址空间，对于32位的进程，可以拥有4GB的虚拟内存，64位进程则更多，可达18EB。只有我们开始使用申请到的虚拟内存时，系统才会将虚拟地址映射到物理地址上，从而让程序使用真实的物理内存。</p>
<a id="more"></a>
<h4 id="内存分页"><a href="#内存分页" class="headerlink" title="内存分页"></a>内存分页</h4><p>系统会对虚拟内存和物理内存进行分页，虚拟内存到物理内存的映射都是以页为最小粒度的。在OSX和早期的iOS系统中，物理和虚拟内存都按照4KB的大小进行分页。iOS近期的系统中，基于A7和A8处理器的系统，物理内存按照4KB分页，虚拟内存按照16KB分页。基于A9处理器的系统，物理和虚拟内存都是以16KB进行分页。系统将内存页分为三种状态。</p>
<p><strong>活跃内存页（active pages）</strong>- 这种内存页已经被映射到物理内存中，而且近期被访问过，处于活跃状态。<br><strong>非活跃内存页（inactive pages）</strong>- 这种内存页已经被映射到物理内存中，但是近期没有被访问过。<br><strong>可用的内存页（free pages）</strong>- 没有关联到虚拟内存页的物理内存页集合。<br>当可用的内存页降低到一定的阀值时，系统就会采取低内存应对措施，在OSX中，系统会将非活跃内存页交换到硬盘上，而在iOS中，则会触发Memory Warning，如果你的App没有处理低内存警告并且还在后台占用太多内存，则有可能被杀掉。</p>
<h4 id="VM-Region"><a href="#VM-Region" class="headerlink" title="VM Region"></a>VM Region</h4><p>为了更好的管理内存页，系统将一组连续的内存页关联到一个VMObject上，VMObject主要包含下面的属性。<br><strong>Resident pages</strong> - 已经被映射到物理内存的虚拟内存页列表<br><strong>Size</strong> - 所有内存页所占区域的大小<br><strong>Pager</strong> - 用来处理内存页在硬盘和物理内存中交换问题<br><strong>Attributes</strong> - 这块内存区域的属性，比如读写的权限控制<br><strong>Shadow</strong> - 用作（copy-on-write）写时拷贝的优化<br><strong>Copy</strong> - 用作（copy-on-write）写时拷贝的优化<br>我们在Instruments的Anonymous VM里看到的每条记录都是一个VMObject或者也可以称之为VM Region</p>
<h3 id="堆（heap）和-VM-Region"><a href="#堆（heap）和-VM-Region" class="headerlink" title="堆（heap）和 VM Region"></a>堆（heap）和 VM Region</h3><p>Instruments中有一个VM Track模版，可以帮助我们清楚的了解heap和VM Region的关系<br>运行Profile，选择Allocation模版，进入后再添加VM Track模版<br><img src="https://i.loli.net/2020/03/05/15FzQntk9DwpAWM.png" alt="s1"><br>下面是我自己写的一个测试用的工程，选择Regions Map选项可以看到内存分配的详细信息</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1719830-874696f094468b59.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s2"><br>我们在VM Track中可以看到，一个VM Region有4种size。<br><strong>Dirty Size</strong><br><strong>Swapped Size</strong><br><strong>Resident Size</strong><br><strong>Virtual Size</strong><br>Virtual Size顾名思义，就是虚拟内存大小，将一个VM Region的结束地址减去起始地址就是这个值。Resident Size指的是实际使用物理内存的大小。Swapped Size则是交换到硬盘上的大小，仅OSX可用。Dirty Size根据官方的解释我的理解是如果一个内存页想要被复用，必须将内容写到硬盘上的话，这个内存页就是Dirty的。下面是官方对Dirty Size的解释。secondary storage可以理解为硬盘。<br>The amount of memory currently being used that must be written to secondary storage before being reused.<br>所以一般来说app运行过程中在堆上动态分配的内存页都是Dirty的，加载动态库或者文件内存映射产生的内存页则是非Dirty的</p>
<p>点击Address Range列的箭头可以看到更详细的内容，这里进入的是SMALL类型的<br><img src="https://upload-images.jianshu.io/upload_images/1719830-3a5cd9b9075f69cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s3"><br>总的来说，堆区会被划分成很多不同的VM Region，不同类型的内存分配根据需求进入不同的VM Region。除了MALLOC_LARGE和MALLOC_SMALL外，还有MALLOC_TINY， MALLOC metadata等等</p>
<h3 id="VM-Tracker列属性解析"><a href="#VM-Tracker列属性解析" class="headerlink" title="VM Tracker列属性解析"></a>VM Tracker列属性解析</h3><p><img src="https://upload-images.jianshu.io/upload_images/1719830-43358cb3164ef4e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s4"><br><strong>% of Res</strong>， 当前Type的VM Regions总Resident Size占比<br><strong>Type</strong>，VM Regions的Type，All和Dirty算是统计性质的Type，<strong>TEXT表示代码段的内存映射，</strong>DATA表示数据段的内存映射。MALLOC_TINY，MALLOC_LARGE，CG Image等Type可以从VM Region的Extend Info中读取出来<br><strong># Regs</strong>，当前Type的VM Region总数<br><strong>Path</strong>，VM Region是从哪个文件映射过来，因为有些类似于__DATA和mapped file的内存块是从文件直接映射过来的。<br><strong>Resident Size</strong>，使用的物理内存量。<br><strong>Dirty Size</strong>，使用中的物理内存块如果不交换到硬盘保存状态就不能复用，那么就是Dirty的内存块，比如你主动malloc出来的内存块，如果不保留其中的状态就把它给别人用，那你肯定就无法恢复这个内存块的信息，所以它是Dirty的。如果是一个映射到内存的文件，就算使用它的内存块，还是可以重新从磁盘载入文件到内存的，所以是非Dirty的，比如最上面图中的mapped file那一行，你可以看到Dirty Size是0。<br><strong>Swapped Size</strong>, 在OSX中，不活跃的内存页可以被交换到硬盘，这是被交换的大小。在iOS中，只有非Dirty的内存页可以被交换，或者说是被卸载。<br><strong>Virtual Size</strong>，VM Regions所占虚拟内存的大小<br><strong>Res. %</strong>，Resident Size在Virtual Size中的占比</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="https://www.jianshu.com/p/553f34b03624" target="_blank" rel="noopener">https://www.jianshu.com/p/553f34b03624</a><br><a href="https://www.jianshu.com/p/f82e2b378455" target="_blank" rel="noopener">https://www.jianshu.com/p/f82e2b378455</a><br><a href="https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Performance/Conceptual/ManagingMemory/Articles/AboutMemory.html</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>虚拟内存</tag>
        <tag>VM region</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 逆向学习</title>
    <url>/2020/03/04/iOS-%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要对iOS逆向所需要的工具或者基础做一个大概的总结，如果有什么遗漏或者错误，欢迎读者指出。<br>想要进行逆向开发，首先就是要对APP进行砸壳，砸壳又需要越狱，当然也可以直接去一些平台下载砸壳后的APP进行逆向，砸壳后就需要对APP进行静态分析和动态分析，用reveal查看视图结构，用hopper查看汇编信息等等。</p>
<a id="more"></a>
<h3 id="越狱"><a href="#越狱" class="headerlink" title="越狱"></a>越狱</h3><p>iOS12可用unc0ver进行越狱，至于其他iOS版本可自己查阅相关资料<br>iOS12越狱可参考<a href="https://zhuanlan.zhihu.com/p/58097735" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/58097735</a><br>iOS13之后可使用<a href="https://checkra.in/" target="_blank" rel="noopener">checkra.in</a></p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>越狱后可以安装<strong>OpenSSH</strong>和<strong>adv-cmds</strong>方便电脑远程连接手机<br><strong>WiFi连接：</strong><br>先确保手机和电脑通处于一个Wifi环境，在手机的网络设置里面找到当前的IP地址<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ ssh root@<span class="number">127.0</span><span class="number">.2</span><span class="number">.3</span></span><br></pre></td></tr></table></figure></p>
<p>root用户的默认密码为：<strong>alpine</strong>，登录成功后可执行 <strong>passwd</strong> 修改密码<br><strong>USB连接：</strong><br>手机先usb连接电脑<br>首先安装<strong>usbmuxd</strong><br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">brew </span><span class="keyword">install </span>usbmuxd</span><br></pre></td></tr></table></figure></p>
<p>然后进行端口映射<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ iproxy <span class="number">2222</span> <span class="number">22</span></span><br></pre></td></tr></table></figure></p>
<p>把当前连接设备的22端口映射到电脑的2222端口上<br>最后进行连接<br><figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line">$ ssh -p <span class="number">2222</span> root@<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure></p>
<p><strong>免密登录：</strong><br>先查看本地(MAC)之前是否已经生成过RSA公私钥，直接进入目录.ssh下查看，如果其中有id_rsa和id_rsa.pub即代表已有，无需重新生成<br>如果没有，直接使用如下命令生成新的<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen</span></span><br></pre></td></tr></table></figure></p>
<p>接着会出现一些问题，全部留空，直接回车即可。之后就可以发现目录.ssh下有了id_rsa和id_rsa.pub了<br>然后就是将本地公钥发到iPhone端<br><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ ssh-<span class="keyword">copy</span>-<span class="built_in">id</span> root@localhost -p <span class="number">2222</span></span><br></pre></td></tr></table></figure></p>
<h3 id="砸壳"><a href="#砸壳" class="headerlink" title="砸壳"></a>砸壳</h3><p>Appstore下载的应用都是加密的，可以使用otool查看是否加密<br><strong>otool -l ting | grep crypt</strong><br>使用<a href="http://www.alonemonkey.com/" target="_blank" rel="noopener">monkeyDev</a>大神的<a href="https://github.com/AloneMonkey/frida-ios-dump" target="_blank" rel="noopener">frida-ios-dump</a>可以实现一键砸壳，非常方便，具体使用方法可参考GitHub</p>
<h3 id="class-dump"><a href="#class-dump" class="headerlink" title="class-dump"></a>class-dump</h3><p>class-dump 是一个工具，它利用了 Objective-C 语言的运行时特性，将存储在 Mach-O 文件中的头文件信息提取出来，并生成对应的 .h 文件。<br>安装class-dump：<br>可以在其<a href="https://link.juejin.im/?target=http%3A%2F%2Fstevenygard.com%2Fprojects%2Fclass-dump%2F" target="_blank" rel="noopener">class-dump 官网</a>下载，将里面的 class-dump 直接放在/usr/local/bin 目录，并给个可执行权限即可 如果/usr/local/bin没有添加到PATH,请自行添加<br>class-dump使用：<br>把砸壳后的ipa文件解压得到payload文件夹。文件夹里面就是.app文件，终端cd到.app文件，然后执行class-dump的命令<br>$class-dump -H WeChat -o ~/Desktop/wechatHeader</p>
<h3 id="hopper"><a href="#hopper" class="headerlink" title="hopper"></a>hopper</h3><p>把砸壳后的可执行文件拖到hopper里面就可以查看对应的汇编代码，可以根据汇编进行自己的逻辑验证</p>
<h3 id="逆向调试"><a href="#逆向调试" class="headerlink" title="逆向调试"></a>逆向调试</h3><p>使用<a href="http://www.alonemonkey.com/" target="_blank" rel="noopener">monkeyDev</a>大神的<a href="http://www.alonemonkey.com/2017/07/12/monkeydev-without-jailbreak/" target="_blank" rel="noopener">无须越狱、自动集成、只需要一个砸壳的应用</a>可以调试砸壳后的应用</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS unc0ver越狱</title>
    <url>/2020/03/04/unc0ver/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><strong>iOS越狱</strong>（<strong>iOS Jailbreaking</strong>）是获取<a href="https://zh.wikipedia.org/wiki/IOS%E8%AE%BE%E5%A4%87%E5%88%97%E8%A1%A8" title="IOS设备列表" target="_blank" rel="noopener">iOS设备</a>的<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%BA%A7%E7%94%A8%E6%88%B7" title="超级用户" target="_blank" rel="noopener">Root权限</a>的技术手段，作为iOS开发者，了解越狱可以更好的做好iOS的攻防。</p>
<a id="more"></a>
<h3 id="安装unc0ver"><a href="#安装unc0ver" class="headerlink" title="安装unc0ver"></a>安装unc0ver</h3><p>安装方式有<strong>个人自签名安装</strong>和<strong>企业证书版本安装</strong><br><strong>个人自签名安装</strong> 需要使用电脑，每次安装有效期7天，需要信任后使用，过期后需要重新签名安装。优点是，可以随时安装开发者发布的任意版本/最新版本unc0ver 越狱工具。<br>unc0ver的GitHub地址：<a href="[https://link.zhihu.com/?target=https%3A//github.com/pwn20wndstuff/Undecimus/releases](https://link.zhihu.com/?target=https%3A//github.com/pwn20wndstuff/Undecimus/releases">pwn20wnd</a><br>)<br>unc0ver支持的版本和设备在GitHub也有列出，可以自行参考<br>可以在GitHub上下载对应的ipa文件，然后在电脑上自行使用<a href="[http://www.cydiaimpactor.com](http://www.cydiaimpactor.com/">Cydia Impactor</a><br>) 进行安装。<br>安装方式很简单，手机usb链接电脑，电脑打开Cydia Impactor，把unc0ver的ipa拖进去就行了，然后输入自己的appid和密码进行签名，安装完成后手机去 <strong>设置-&gt;通用-&gt;描述文件</strong> 里信任一下证书<br><img src="https://upload-images.jianshu.io/upload_images/1719830-13a758e599fce196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="impactor"></p>
<p><strong>企业证书版本安装</strong>无需电脑，在线安装，安装后需要信任证书使用。每个企业证书理论上一年有效期，不过容易失效，失效后无法打开，需要等待网站签名后再次下载安装。优点是，无需电脑，缺点是容易证书失效，需要等待才能使用最新版本。<br>企业证书版可以去以下两个网站下载安装<br><a href="[app.ignition.fun/](https://link.zhihu.com/?target=https%3A//app.ignition.fun/">Ignition</a><br>) app.ignition.fun/<br><a href="[next.tweakboxapp.com](https://link.zhihu.com/?target=https%3A//next.tweakboxapp.com">Tweakboxapp</a><br>) next.tweakboxapp.com</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1719830-f4b8464bbe88f2a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ignition"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1719830-87ff9b89f6111328.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Tweakboxapp"></p>
<p>企业版同样需要去设置里信任描述证书</p>
<h3 id="开始越狱"><a href="#开始越狱" class="headerlink" title="开始越狱"></a>开始越狱</h3><p>打开unc0ver直接点击Jailbreak就行了，然后手机会重启几次，中间如果出现弹窗，直接点击OK就行了，如果一直卡在某一步没有动，可以杀死unc0ver重新进行Jailbreak，当重启四次左右的时候应该就能看到手机里多了Cydia，那就表示越狱成功了<br><img src="https://upload-images.jianshu.io/upload_images/1719830-c00f6e8b68da1316.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Jailbreak"></p>
<p>对于iOS12的系统，越狱成功后需要用pp助手安装 <strong>乐网</strong> 否则Cydia可能无法联网</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1719830-1589d6bcff4a8462.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Ad"></p>
<p>然后就可以用Cydia添加源了并且安装自己想要的插件了<br><img src="https://upload-images.jianshu.io/upload_images/1719830-547ddbb52683c49e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="sources"></p>
<p>如果越狱后想恢复到未越狱状态，可以用unc0ver还原，打开unc0ver的设置页面,把所有开关都关闭，只打开Restore RootFS, 然后回到unc0ver首页执行restore即可<br><img src="https://upload-images.jianshu.io/upload_images/1719830-d5bb783e78963abf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="re"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zhihu.com/people/ai-cheng-11-82" target="_blank" rel="noopener">艾橙君</a> - <a href="[https://zhuanlan.zhihu.com/p/58097735](https://zhuanlan.zhihu.com/p/58097735">unc0ver iOS 12.0 - 12.1.2 越狱指南</a><br>)</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>越狱</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift访问控制权限</title>
    <url>/2018/07/07/Swift-Permission/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Swift 3中，新增了 fileprivate 和 open 权限，而在Swift4 中，对 fileprivate 和 private 的访问范围做出了调整。访问控制限制你在不同源文件和 module 之前代码和代码之前的访问。这个特性让你可以隐藏一些代码的实现，和明确一些可以访问和使用的接口。</p>
<a id="more"></a>
<h3 id="Modules-和-源文件"><a href="#Modules-和-源文件" class="headerlink" title="Modules 和 源文件"></a>Modules 和 源文件</h3><p>Swift 的访问控制模型是基于 module 和 源文件的。<br>一个 module 是一个独立的代码建造单元，例如一个 framework 或者 application 可以构建和包装成一个可以被其他 module 通过 Swift 的关键字 import 的单元。<br>一个源文件是在一个 module 里单独的 Swift 源码（或在 一个 app 或 framework 里的单独的文件） 。虽然常见的是在分开的源文件里定义单独的类型，但一个单独的源文件也能包含多个类型，方法等的定义。</p>
<h3 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h3><p>Swift 提供5个不同的访问级别，权限最高的是<code>open</code>，依次是 <code>public</code>，<code>internal</code>，<code>fileprivate</code>，最低的是<code>private</code>。默认使用的级别是 <code>internal</code>。</p>
<h4 id="open-amp-public"><a href="#open-amp-public" class="headerlink" title="open &amp; public"></a>open &amp; public</h4><p>使用 open 和 public 标记的实体在他们定义的 module 中的任意文件中都可以使用，并且在 import 了其定义的 module 的其他 module 的源文件中也能使用。一般在 framework 中指定公开的接口里使用 open 或者 public 级别。</p>
<p><strong>open 和 public 的区别</strong></p>
<ul>
<li>拥有 public 权限或者更低权限的类，只能在其定义的 module 中被子类化</li>
<li>拥有 public 权限或者更低权限的类的成员，只能在其定义的 module 中被重写或子类化</li>
<li>拥有open 权限的类可以在其定义和 import 的 module 中子类化</li>
<li>拥有open 权限的类成员可以在其定义和 import 的 module 中被重写或子类化</li>
</ul>
<h4 id="internal"><a href="#internal" class="headerlink" title="internal"></a>internal</h4><p>internal 修饰的实体在其定义 module 中的任意源文件中都可以访问，但是在其他 module 的任意源文件中都访问不了。一般在定义app 或者 framework 内部的结构的时候，使用 internal 级别。</p>
<h4 id="fileprivate"><a href="#fileprivate" class="headerlink" title="fileprivate"></a>fileprivate</h4><p>fileprivate 限制了只能在其定义的源文件里面使用。使用 fileprivate 权限以隐藏其实现细节。当其只在整个源文件中使用的时候，使用 fileprivate 修饰。</p>
<h4 id="private"><a href="#private" class="headerlink" title="private"></a>private</h4><p>private 访问权限限制其只能在定义的范围内，和其在同一文件中的 extension 中使用。当其只在当个声明中使用的时候，使用 private 修饰。</p>
<h3 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h3><p><strong>子类：</strong> 子类的访问级别不能高于父类，但是子类复写的父类方法的访问级别可以高于父类<br><strong>枚举：</strong> 枚举的每个值都和他们所属的枚举拥有相同的级别，并且并不能定义单独的访问级别。<br><strong>协议：</strong> 你可以给协议指定访问级别，并且对于协议的每一项来说，访问级别都和协议相同。并且你不能单独给协议中单独的方法等定义不同的访问级别。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="http://clavis.me/iOS/Access-Control-of-Swift4/" target="_blank" rel="noopener">Swift4 访问控制权限</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift可选类型详解</title>
    <url>/2018/07/07/Swift-Optional/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Swift是一门类型安全的语言。Swift的可选类型会进行编译检查，防止一些常见的运行时错误。在 Swift 中，当我们声明一个变量的时候，默认情况下是 非可选类型 (non-optional) ，也就是说，你必须指定一个不为 nil 的值。如果你硬是要把一个非可选类型的变量设为 nil ，那么编译器就会报错。</p>
<a id="more"></a>
<p>Swift中的nil，必须用可选类型接收。你可以给可选类型赋值为nil来表示他没有值，如果你声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nil ，也就是说可选类型可以为nil也可以有值，非可选类型不能为nil必须有值。Swift 的 nil 和 Objective-C 中的 nil 并不一样。在 Objective-C 中，nil 是一个指向不存在对象的指针。在 Swift 中，nil 不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为 nil，不只是对象类型。</p>
<h3 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h3><p>当你确定可选类型一定包含值之后，你可以在可选的名字后面加一个感叹号<code>!</code>来解包获取值。这被称为可选值得强制解包（forced unwrapping）<br>例如:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var user_name: String?</span><br><span class="line">        ...</span><br><span class="line">        if user_name != nil &#123;</span><br><span class="line">            print(&quot;user_name:&quot;, user_name!)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="可选绑定"><a href="#可选绑定" class="headerlink" title="可选绑定"></a>可选绑定</h3><p>使用可选绑定可以去辨别一个可选类型是否包含值，如果包含就把值赋给一个临时常量或变量<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if let name = user_name &#123;</span><br><span class="line">            print(&quot;user_name:&quot;, name)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 if 条件语句中使用常量和变量来创建一个可选绑定，仅在 if 语句的第一个分支中才能获取到值。相反，在 guard 语句中使用常量和变量来创建一个可选绑定，仅在 guard 语句外且在语句后才能获取到值,guard和let是相反的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guard let name = user_name else &#123;</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="隐式解析可选类型"><a href="#隐式解析可选类型" class="headerlink" title="隐式解析可选类型"></a>隐式解析可选类型</h3><p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次访问时都不需要检查和解析可选类型的值，因为可以安全的确定它总会有值。这种类型的可选状态被定义为隐式解析可选类型（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号<code>?</code>改成感叹号<code>!</code>来声明一个隐式解析可选类型。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let user_name: String! = &quot;user_name&quot;</span><br><span class="line">let default_name: String = user_name</span><br></pre></td></tr></table></figure></p>
<p>一个隐式解析可选类型其实就是一个普通的可选类型，但是可以被当做非可选类型来使用，并不需要每次都使用解析来获取可选值。你可以把隐式解析可选类型当做一个可以自动解析的可选类型。你要做的只是声明的时候把感叹号放到类型的结尾，而不是每次取值的时候在可选类型名字结尾放置一个!。如果一个变量之后可能变成nil的话请不要使用隐式解析可选类型。如果你需要在变量的生命周期中判断是否是nil的话，请使用普通可选类型。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://xiaozhuanlan.com/topic/2789610453" target="_blank" rel="noopener">Swift Optionals/可选类型详解</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Optional</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS Core Animation(核心动画)</title>
    <url>/2017/05/08/iOS-Core-Animation/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>Core Animation</strong>，中文翻译为核心动画，它是一组非常强大的动画处理API，使用它能做出非常炫丽高效的动画效果。<br><strong>Core Animation</strong>可以用在<strong>Mac OS X</strong>和<strong>iOS</strong>平台。<br><strong>Core Animation</strong>的动画执行过程都是在后台操作的，不会阻塞主线程。<br>要注意的是，<strong>Core Animation是直接作用在`CALayer上的，并非UIView</strong>。</p>
<a id="more"></a>
<h2 id="CALayer的属性"><a href="#CALayer的属性" class="headerlink" title="CALayer的属性"></a>CALayer的属性</h2><p>既然Core Animation是作用在CALayer上的，那么我们就要先了解下CALayer的一些常用属性:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The bounds of the layer. Defaults to CGRectZero. Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGRect</span> bounds;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The position in the superlayer that the anchor point of the layer's</span></span><br><span class="line"><span class="comment"> * bounds rect is aligned to. Defaults to the zero point. Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> position;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Defines the anchor point of the layer's bounds rect, as a point in</span></span><br><span class="line"><span class="comment"> * normalized layer coordinates - '(0, 0)' is the bottom left corner of</span></span><br><span class="line"><span class="comment"> * the bounds rect, '(1, 1)' is the top right corner. Defaults to</span></span><br><span class="line"><span class="comment"> * '(0.5, 0.5)', i.e. the center of the bounds rect. Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CGPoint</span> anchorPoint;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* A transform applied to the layer relative to the anchor point of its</span></span><br><span class="line"><span class="comment"> * bounds rect. Defaults to the identity transform. Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">CATransform3D</span> transform;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The background color of the layer. Default value is nil. Colors</span></span><br><span class="line"><span class="comment"> * created from tiled patterns are supported. Animatable. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>) <span class="built_in">CGColorRef</span> backgroundColor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> opacity;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>bounds</strong>：大小</li>
<li><strong> position</strong>: 位置(默认指中点，具体由anchorPoint决定)</li>
<li><strong> anchorPoint</strong>：锚点(x,y的范围都是0-1)，决定了position</li>
<li><strong> transform</strong>: 形变属性</li>
<li><strong> backgroundColor</strong>: 背景颜色(CGColorRef类型)</li>
<li><strong>opacity</strong>: 透明度</li>
</ul>
<h3 id="position和anchorPoint"><a href="#position和anchorPoint" class="headerlink" title="position和anchorPoint"></a>position和anchorPoint</h3><p><strong>position</strong>用来设置CALayer在父层中的位置<br>以父层的左上角为原点(0, 0)。</p>
<p><strong>anchorPoint</strong>称为“定位点”、“锚点”，决定着CALayer身上的哪个点会在position属性所指的位置。以自己的左上角为原点(0, 0)，它的x、y取值范围都是0~1，默认值为中心点（0.5, 0.5）</p>
<p>关于position和anchorPoint可参考<a href="https://leroyli.github.io/2017/05/08/iOS-position-and-anchorPoint/" target="_blank" rel="noopener">iOS 理解position与anchorPoint</a></p>
<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>每一个UIView内部都默认关联着一个CALayer，我们可用称这个Layer为<strong>Root Layer（根层）</strong>,所有的<strong>非Root Layer</strong>，也就是手动创建的CALayer对象，都存在着隐式动画.</p>
<p>当对非Root Layer的部分属性进行修改时，默认会自动产生一些动画效果，而这些属性称为Animatable Properties(可动画属性)。</p>
<p>可以通过事务关闭隐式动画：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">CATransaction</span> begin];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**关闭隐式动画**/</span> </span><br><span class="line">[<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line"></span><br><span class="line">layer.position = <span class="built_in">CGPointMake</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">[<span class="built_in">CATransaction</span> commit];</span><br></pre></td></tr></table></figure></p>
<h2 id="Core-Animation结构"><a href="#Core-Animation结构" class="headerlink" title="Core Animation结构"></a>Core Animation结构</h2><p>Core Animation结构如图：</p>
<img src="/2017/05/08/iOS-Core-Animation/coreAnimation.png">
<p>其中灰色虚线表示继承关系，红色表示遵守协议。</p>
<p>核心动画中所有类都遵守<strong>CAMediaTiming</strong>协议。<br><strong>CAAnaimation</strong>是个抽象类，不具备动画效果，必须用它的子类才有动画效果。</p>
<p><strong>CAAnimationGroup</strong>和<strong>CATransition</strong>才有动画效果，<strong>CAAnimationGroup</strong>是个动画组，可以同时进行缩放，旋转（同时进行多个动画）。</p>
<p><strong>CATransition</strong>是转场动画，界面之间跳转（切换）都可以用转场动画。</p>
<p><strong>CAPropertyAnimation</strong>也是个抽象类，本身不具备动画效果，只有子类才有。</p>
<p><strong>CABasicAnimation</strong>基本动画，做一些简单效果。</p>
<p><strong>CAKeyframeAnimation</strong>帧动画，做一些连续的流畅的动画。</p>
<h2 id="CAAnimation——简介"><a href="#CAAnimation——简介" class="headerlink" title="CAAnimation——简介"></a>CAAnimation——简介</h2><p>CAAnimation是所有动画对象的父类，负责控制动画的持续时间和速度，是个抽象类，不能直接使用，应该使用它具体的子类.</p>
<p><strong>CAAnimation属性</strong></p>
<ul>
<li><p><strong>duration</strong>: 动画的持续时间  </p>
</li>
<li><p><strong>repeatCount</strong> : 重复次数，无限循环可以设置HUGE_VALF或者MAXFLOAT</p>
</li>
<li><p><strong>repeatDuration</strong> : 重复时间</p>
</li>
<li><p><strong>removedOnCompletion</strong> :默认为<strong>YES</strong>，代表动画执行完毕后就从图层上移除，图形会恢复到动画执行前的状态。如果想让图层保持显示动画执行后的状态，那就设置为<strong>NO</strong>，不过还要设置fillMode为<strong>kCAFillModeForwards</strong></p>
</li>
<li><p><strong>fillMode</strong> : 决定当前对象在非active时间段的行为。比如动画开始之前或者动画结束之</p>
</li>
<li><p><strong>beginTime</strong> : 可以用来设置动画延迟执行时间，若想延迟2s，就设置为CACurrentMediaTime()+2，CACurrentMediaTime()为图层的当前时间</p>
</li>
<li><p><strong>timingFunction</strong> : 速度控制函数，控制动画运行的节奏</p>
</li>
<li><strong>delegate</strong> : 动画代理</li>
</ul>
<hr>
<p><strong>fillMode枚举</strong></p>
<ul>
<li><p><strong>kCAFillModeRemoved:</strong> 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态</p>
</li>
<li><p><strong>kCAFillModeForwards:</strong> 当动画结束后，layer会一直保持着动画最后的状态</p>
</li>
<li><p><strong>kCAFillModeBackwards:</strong> 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。</p>
</li>
<li><p><strong>kCAFillModeBoth:</strong> 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态</p>
</li>
</ul>
<hr>
<p><strong> CAMediaTimingFunction枚举</strong></p>
<ul>
<li><p><strong>kCAMediaTimingFunctionLinear（线性）</strong>：匀速，给你一个相对静态的感觉</p>
</li>
<li><p><strong>kCAMediaTimingFunctionEaseIn（渐进）</strong>：动画缓慢进入，然后加速离开</p>
</li>
<li><p><strong>kCAMediaTimingFunctionEaseOut（渐出）</strong>：动画全速进入，然后减速的到达目的地</p>
</li>
<li><p><strong>kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）</strong>：动画缓慢的进入，中间加速，然后减速的到达目的地。这个是默认的动画行为。</p>
</li>
</ul>
<h2 id="CABasicAnimation——基本动画"><a href="#CABasicAnimation——基本动画" class="headerlink" title="CABasicAnimation——基本动画"></a>CABasicAnimation——基本动画</h2><p>基本动画，执行过程随着动画的进行，在长度为duration的持续时间内，keyPath相应属性的值从fromValue渐渐地变为toValue。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lyz_basicAnimation&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *animation   = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">    <span class="comment">/**removedOnCompletion        = NO 并且 fillMode = kCAFillModeForwards 的时候动画执行完毕会停留在执行后的状态**/</span></span><br><span class="line">    animation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">    animation.fillMode            = kCAFillModeForwards;</span><br><span class="line">    </span><br><span class="line">    animation.fromValue           = @(<span class="number">150</span>);</span><br><span class="line">    animation.toValue             = @(<span class="number">250</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//动画是否按原路径返回</span></span><br><span class="line">    animation.autoreverses        = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    animation.duration            = <span class="number">1</span>;</span><br><span class="line">    animation.repeatCount         = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.contentView.layer addAnimation:animation forKey:<span class="string">@"position"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<strong>fillMode = kCAFillModeForwards</strong>同时<strong>removedOnComletion = NO</strong>，那么在动画执行完毕后，图层会保持显示动画执行后的状态。但在实质上，图层的属性值还是动画执行前的初始值，并没有真正被改变。</p>
<h2 id="CAKeyframeAnimation——关键帧动画"><a href="#CAKeyframeAnimation——关键帧动画" class="headerlink" title="CAKeyframeAnimation——关键帧动画"></a>CAKeyframeAnimation——关键帧动画</h2><p>关键帧动画，也是CAPropertyAnimation的子类，与CABasicAnimation的区别是：</p>
<ol>
<li><p>CABasicAnimation只能从一个数值（fromValue）变到另一个数值（toValue），而CAKeyframeAnimation会使用一个NSArray保存这些数值</p>
</li>
<li><p>CABasicAnimation可看做是只有2个关键帧的CAKeyframeAnimation</p>
</li>
</ol>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lyz_keyframeAnimatin&#123;</span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *animation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    </span><br><span class="line">    animation.values               = @[@(<span class="number">0</span>),@(<span class="number">-1</span>),@(<span class="number">0</span>),@(<span class="number">1</span>),@(<span class="number">0</span>)];</span><br><span class="line">    </span><br><span class="line">    animation.repeatCount          = <span class="number">10</span>;</span><br><span class="line">    animation.duration             = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    animation.removedOnCompletion  = <span class="literal">NO</span>;</span><br><span class="line">    animation.fillMode             = kCAFillModeForwards;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.contentView.layer addAnimation:animation forKey:<span class="string">@"rotaion"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CAAnimationGroup——动画组"><a href="#CAAnimationGroup——动画组" class="headerlink" title="CAAnimationGroup——动画组"></a>CAAnimationGroup——动画组</h2><p>动画组，是CAAnimation的子类，可以保存一组动画对象，将CAAnimationGroup对象加入层后，组中所有动画对象可以同时并发运行。</p>
<p>默认情况下，一组动画对象是同时运行的，也可以通过设置动画对象的beginTime属性来更改动画的开始时间。</p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lyz_groupAnimation&#123;</span><br><span class="line">    <span class="built_in">CABasicAnimation</span> *basicAnimation   = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"position.x"</span>];</span><br><span class="line">    basicAnimation.removedOnCompletion = <span class="literal">NO</span>;</span><br><span class="line">    basicAnimation.fillMode            = kCAFillModeForwards;</span><br><span class="line">    basicAnimation.fromValue           = @(<span class="number">150</span>);</span><br><span class="line">    basicAnimation.toValue             = @(<span class="number">250</span>);</span><br><span class="line">    basicAnimation.autoreverses        = <span class="literal">YES</span>;</span><br><span class="line">    basicAnimation.duration            = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAKeyframeAnimation</span> *keyframeAnimation = [<span class="built_in">CAKeyframeAnimation</span> animationWithKeyPath:<span class="string">@"transform.rotation.z"</span>];</span><br><span class="line">    keyframeAnimation.values               = @[@(<span class="number">0</span>),@(<span class="number">-1</span>),@(<span class="number">0</span>),@(<span class="number">1</span>),@(<span class="number">0</span>)];</span><br><span class="line">    keyframeAnimation.duration             = <span class="number">2</span>;</span><br><span class="line">    keyframeAnimation.removedOnCompletion  = <span class="literal">NO</span>;</span><br><span class="line">    keyframeAnimation.fillMode             = kCAFillModeForwards;</span><br><span class="line">    keyframeAnimation.autoreverses         = <span class="literal">YES</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CAAnimationGroup</span> *groupAnimation = [<span class="built_in">CAAnimationGroup</span> animation];</span><br><span class="line">    groupAnimation.animations        = @[basicAnimation,keyframeAnimation];</span><br><span class="line">    groupAnimation.repeatCount       = <span class="number">5</span>;</span><br><span class="line">    groupAnimation.duration          = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.contentView.layer addAnimation:groupAnimation forKey:<span class="string">@"group"</span>];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CATransition——转场动画"><a href="#CATransition——转场动画" class="headerlink" title="CATransition——转场动画"></a>CATransition——转场动画</h2><p>它是CAAnimation的子类，用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。 其中最主要的就是 type 和 subType 这两个属性。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">NSString</span> *type</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *subtype</span><br></pre></td></tr></table></figure>
<p><strong>Type: 动画的类型</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Common transition types. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionFade</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionMoveIn</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionPush</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionReveal</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>SubType： 动画类型的方向</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Common transition subtypes. */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionFromRight</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionFromLeft</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionFromTop</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="built_in">CA_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> kCATransitionFromBottom</span><br><span class="line">    <span class="built_in">CA_AVAILABLE_STARTING</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>);</span><br></pre></td></tr></table></figure></p>
<p>示例代码：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)lyz_transitionAnimation&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CATransition</span> *animation = [<span class="built_in">CATransition</span> animation];</span><br><span class="line">    [animation setDuration:<span class="number">1.25</span>f];</span><br><span class="line">    [animation setTimingFunction:[<span class="built_in">CAMediaTimingFunction</span> functionWithName:kCAMediaTimingFunctionEaseIn]];</span><br><span class="line">    [animation setType:kCATransitionReveal];</span><br><span class="line">    [animation setSubtype: kCATransitionFromTop];</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.navigationController.view.layer addAnimation:animation forKey:<span class="string">@"push"</span>];</span><br><span class="line">    LYZAnimationViewController *vc = [[LYZAnimationViewController alloc] init];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:vc animated:<span class="literal">YES</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是一些对Core Animation的理解和认识，如果需要Demo可以到<a href="https://github.com/leroyli/LYZCAAnaimationDemo" target="_blank" rel="noopener">这里</a>下载。写的不好的地方请大家批评指正，谢谢。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/u/a31d5d923a5d" target="_blank" rel="noopener"><strong>加斯加的猿</strong></a>:<a href="http://www.jianshu.com/p/8c1c1697c0ce" target="_blank" rel="noopener">iOS开发基础知识：Core Animation(核心动画)</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Animation</tag>
        <tag>CoreAnimation</tag>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 理解position和anchorPoint</title>
    <url>/2017/05/08/iOS-position-and-anchorPoint/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相信很多刚接触CALayer的人都会遇到一下几个麻烦：<br><strong>1. 为什么修改anchorPoint会移动layer的位置？</strong><br><strong>2. CALayer的position点是哪一点呢?</strong><br><strong>3. anchorPoint与position有什么关系？</strong><br>今天我们就来讨论一下这些问题</p>
<a id="more"></a>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>每一个UIView内部都默认关联着一个CALayer, UIView有frame、bounds和center三个属性，CALayer也有类似的属性，分别为frame、bounds、position、anchorPoint。frame和bounds比较好理解，bounds可以视为x坐标和y坐标都为0的frame，那<strong>position</strong>、<strong>anchorPoint</strong>是什么呢？先看看两者的原型，可知都是<strong>CGPoint</strong>点。</p>
<p><strong>@property CGPoint position</strong><br><strong>@property CGPoint anchorPoint</strong></p>
<h2 id="anchorPoint"><a href="#anchorPoint" class="headerlink" title="anchorPoint"></a>anchorPoint</h2><p>从一个例子开始入手吧，想象一下，把一张A4白纸用图钉订在书桌上，如果订得不是很紧的话，白纸就可以沿顺时针或逆时针方向围绕图钉旋转，这时候图钉就起着支点的作用。我们要解释的anchorPoint就相当于白纸上的图钉，它主要的作用就是用来作为变换的支点，旋转就是一种变换，类似的还有平移、缩放。</p>
<p>继续扩展，很明显，白纸的旋转形态随图钉的位置不同而不同，图钉订在白纸的正中间与左上角时分别造就了两种旋转形态，这是由图钉（anchorPoint）的位置决定的。如何衡量图钉（anchorPoint）在白纸中的位置呢？在iOS中，anchorPoint点的值是用一种相对bounds的比例值来确定的，在白纸的左上角、右下角，anchorPoint分为为(0,0), (1, 1)，也就是说anchorPoint是在单元坐标空间(同时也是左手坐标系)中定义的。类似地，可以得出在白纸的中心点、左下角和右上角的anchorPoint为(0.5,0.5), (0,1), (1,0)。</p>
<p>然后再来看下面两张图，注意图中分iOS与MacOS，因为两者的坐标系不相同，iOS使用左手坐标系，坐标原点在左上角，MacOS使用右手坐标系，原点在左下角，我们看iOS部分即可。 </p>
<img src="/2017/05/08/iOS-position-and-anchorPoint/anchorpoint1.png">
<p>图1.<br><img src="/2017/05/08/iOS-position-and-anchorPoint/anchorpoint2.png"><br>图2.</p>
<p>像UIView有superView与subView的概念一样，CALayer也有superLayer与layer的概念，前面说到的白纸和图中的矩形可以理解为layer，书桌和图中矩形以外的坐标系可以理解成superLayer。如果各自以左上角为原点，则在图中有相对的两个坐标空间。</p>
<h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p>在图1中，anchorPoint有(0.5,0.5)和(0,0)两种情况，分别为矩形的中心点与原点。那么，这两个anchorPoint在superLayer中的实际位置分别为多少呢？简单计算一下就可以得到(100, 100)和(40, 60)，把这两个值分别与各自的position值比较，发现完全一致，该不会是巧合？</p>
<p>这时候可以大胆猜测一下，position是不是就是anchorPoint在superLayer中的位置呢？答案是确定的，更确切地说，position是layer中的anchorPoint点在superLayer中的位置坐标。因此可以说, position点是相对suerLayer的，anchorPoint点是相对layer的，两者是相对不同的坐标空间的一个重合点。</p>
<p>再来看看position的原始定义： The layer’s position in its superlayer’s coordinate space。<br>中文可以理解成为position是layer相对superLayer坐标空间的位置，很显然，这里的位置是根据anchorPoint来确定的。</p>
<p>图2中是矩形沿不同的anchorPoint点旋转的形态，这就是类似于刚才讲的图钉订在白纸的正中间与左上角时分别造就了两种旋转形态。</p>
<h2 id="anchorPoint、position、frame之间的关系"><a href="#anchorPoint、position、frame之间的关系" class="headerlink" title="anchorPoint、position、frame之间的关系"></a>anchorPoint、position、frame之间的关系</h2><p>anchorPoint的默认值为(0.5,0.5)，也就是anchorPoint默认在layer的中心点。默认情况下，使用addSublayer函数添加layer时，如果已知layer的frame值，根据上面的结论，那么position的值便可以用下面的公式计算：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">position.x = frame.origin.x + <span class="number">0.5</span> * bounds.size.width；  </span><br><span class="line">position.y = frame.origin.y + <span class="number">0.5</span> * bounds.size.height；</span><br></pre></td></tr></table></figure></p>
<p>里面的0.5是因为anchorPoint取默认值，更通用的公式应该是下面的：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">position.x = frame.origin.x + anchorPoint.x * bounds.size.width；  </span><br><span class="line">position.y = frame.origin.y + anchorPoint.y * bounds.size.height；</span><br></pre></td></tr></table></figure></p>
<p>下面再来看另外两个问题，如果单方面修改layer的position位置，会对anchorPoint有什么影响呢？修改anchorPoint又如何影响position呢？<br>根据代码测试，两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。换句话说，frame.origin由position和anchorPoint共同决定，上面的公式可以变换成下面这样的<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  </span><br><span class="line">frame.origin.y = position.y - anchorPoint.y * bounds.size.height；</span><br></pre></td></tr></table></figure></p>
<p>这就解释了为什么修改anchorPoint会移动layer，因为position不受影响，只能是frame.origin做相应的改变，因而会移动layer。</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在Apple doc对frame的描述中有这么一句话：</p>
<blockquote>
<p><em>Layers have an implicit frame that is a function of the position, bounds, anchorPoint, and transform properties.</em></p>
</blockquote>
<p>可以看到我们推导的公式基本符合这段描述，只不过还缺少了transform，加上transform的话就比较复杂，这里就不展开讲了。</p>
<p>Apple doc中还有一句描述是这样的：</p>
<blockquote>
<p><em>When you specify the frame of a layer, position is set relative to the anchor point. When you specify the position of the layer, bounds is set relative to the anchor point.</em></p>
</blockquote>
<p>大意是：当你设置图层的frame属性的时候，position根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds会根据锚点(anchorPoint)来确定。</p>
<p>这段翻译的上半句根据前面的公式容易理解，后半句可能就有点令人迷惑了，当修改position时，bounds的width与height会随之修改吗？其实,position是点，bounds是矩形，根据锚点(anchorPoint)来确定的只是它们的位置，而不是内部属性。所以，上面这段英文这么翻译就容易理解了：</p>
<p><strong>当你设置图层的frame属性的时候，position点的位置（也就是position坐标）根据锚点（anchorPoint）的值来确定，而当你设置图层的position属性的时候，bounds的位置（也就是frame的orgin坐标）会根据锚点(anchorPoint)来确定。</strong></p>
<p>在实际情况中，可能还有这样一种需求，我需要修改anchorPoint，但又不想要移动layer也就是不想修改frame.origin，那么根据前面的公式，就需要position做相应地修改。简单地推导，可以得到下面的公式：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">positionNew.x = positionOld.x + (anchorPointNew.x - anchorPointOld.x)  * bounds.size.width  </span><br><span class="line">positionNew.y = positionOld.y + (anchorPointNew.y - anchorPointOld.y)  * bounds.size.height</span><br></pre></td></tr></table></figure>
<p>但是在实际使用没必要这么麻烦。修改anchorPoint而不想移动layer，在修改anchorPoint后再重新设置一遍frame就可以达到目的，这时position就会自动进行相应的改变。写成函数就是下面这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>) setAnchorPoint:(<span class="built_in">CGPoint</span>)anchorpoint forView:(<span class="built_in">UIView</span> *)view&#123;</span><br><span class="line">  <span class="built_in">CGRect</span> oldFrame = view.frame;</span><br><span class="line">  view.layer.anchorPoint = anchorpoint;</span><br><span class="line">  view.frame = oldFrame;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1. position是layer中的anchorPoint在superLayer中的位置坐标。</strong><br><strong>2. 互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性。</strong><br><strong>3. frame、position与anchorPoint有以下关系：</strong><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  </span><br><span class="line">frame.origin.y = position.y - anchorPoint.y * bounds.size.height；</span><br></pre></td></tr></table></figure></p>
<p>第2条的互不影响原则还可以这样理解：<strong>position与anchorPoint是处于不同坐标空间中的重合点，修改重合点在一个坐标空间的位置不影响该重合点在另一个坐标空间中的位置。</strong></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://wonderffee.github.io/" target="_blank" rel="noopener">Wonderffee’s Blog</a>:<a href="http://wonderffee.github.io/blog/2013/10/13/understand-anchorpoint-and-position/" target="_blank" rel="noopener">彻底理解position与anchorPoint</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>position</tag>
        <tag>anchorPoint</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 使用第三方字体</title>
    <url>/2017/05/08/iOS-Font/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在iOS的项目开发中经常遇到需要使用一些自定义的字体文件，比如<em>仿宋_GB2312</em>、<em>华康少女体</em>等。之前我们为了使用这些自定义的字体，在应用的资源包中放入这些字体文件。因为字体文件通常比较大，有的一个字库就达到10M以上，这样打包后的ipa文件的体积就可能会变得很大，对于只有个别的模块需要特殊的字体样式的应用来说很不划算，那么在iOS6.0以后苹果就开放了动态加载字体的权限。下面就iOS中使用字体的这两种方式进行介绍。</p>
<a id="more"></a>
<h2 id="使用静态字体"><a href="#使用静态字体" class="headerlink" title="使用静态字体"></a>使用静态字体</h2><p>将字体文件拷贝到项目工程中，在<code>Info.plist</code>文件中添加<code>Fonts provided by application</code>的配置项，其中每一个Item对应的是字体文件的名称，如<strong>huakangshaonv.ttf</strong>.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1719830-df5bc7aa71c0e64e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fontDemo ScreenShot.png"></p>
<p>然后就可以调用<code>+ (UIFont *)fontWithName:(NSString *)fontName size:(CGFloat)fontSize</code>使用字体，如果不知道fontName可以遍历打印出来：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)allFont</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *fontFamilies = [<span class="built_in">UIFont</span> familyNames];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *fontFamily <span class="keyword">in</span> fontFamilies)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *fontNames = [<span class="built_in">UIFont</span> fontNamesForFamilyName:fontFamily];</span><br><span class="line">        <span class="built_in">NSLog</span> (<span class="string">@"&gt;&gt;&gt; fontFamily : %@ , fontNames : %@"</span>, fontFamily, fontNames);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用动态字体"><a href="#使用动态字体" class="headerlink" title="使用动态字体"></a>使用动态字体</h2><p>在网易新闻iOS客户端中可以使用自定义的字体，对于未下载的字体可先下载然后安装下次就能自动设置为该字体，效果如下：</p>
<img src="/2017/05/08/iOS-Font/wangyiFont.png">
<p>下面就该功能简单介绍实现的步骤</p>
<ul>
<li><strong>下载字体文件</strong></li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)downloadZipFile:(<span class="built_in">NSString</span> *)fileUrl toPath:(<span class="built_in">NSString</span> *)path</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:fileUrl];</span><br><span class="line">    <span class="built_in">NSString</span> *fileName = [url lastPathComponent];</span><br><span class="line">    <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url options:<span class="number">0</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span>(!error)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *zipPath = [path stringByAppendingPathComponent:fileName];</span><br><span class="line">        [data writeToFile:zipPath options:<span class="number">0</span> error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span>(!error)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> zipPath;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>解压zip压缩包</strong></li>
</ul>
<p>iOS中解压zip压缩文件非常方便，使用<a href="https://github.com/mattconnolly/ZipArchive" target="_blank" rel="noopener">ZipArchive</a>这个开源项目按照如下的方式即可快速解压zip文件。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)expandZipFile:(<span class="built_in">NSString</span> *)src toPath:(<span class="built_in">NSString</span> *)desc</span><br><span class="line">&#123;</span><br><span class="line">    ZipArchive *za = [[ZipArchive alloc] init];</span><br><span class="line">    <span class="keyword">if</span> ([za UnzipOpenFile:src])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">BOOL</span> ret = [za UnzipFileTo:desc overWrite:<span class="literal">YES</span>];<span class="comment">//解压文件</span></span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *zipName = [src lastPathComponent];<span class="comment">//获取zip文件的文件名</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:zipPath error:<span class="literal">nil</span>];<span class="comment">//删除zip压缩包</span></span><br><span class="line">            zipName = [zipName substringToIndex:[zipName rangeOfString:<span class="string">@".zip"</span>].location];<span class="comment">//获取解压到的文件夹</span></span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">self</span>.downloadPath stringByAppendingPathComponent:zipName];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注册指定路径下的字体文件</strong></li>
</ul>
<p>下载回来的字体文件如果不做处理是不能直接使用的，使用前需要先注册然后才能使用，注册方式如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)registerFont:(<span class="built_in">NSString</span> *)fontPath</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSData</span> *dynamicFontData = [<span class="built_in">NSData</span> dataWithContentsOfFile:fontPath];</span><br><span class="line">    <span class="keyword">if</span> (!dynamicFontData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFErrorRef</span> error;</span><br><span class="line">    <span class="built_in">CGDataProviderRef</span> providerRef = <span class="built_in">CGDataProviderCreateWithCFData</span>((__bridge <span class="built_in">CFDataRef</span>)dynamicFontData);</span><br><span class="line">    <span class="built_in">CGFontRef</span> font = <span class="built_in">CGFontCreateWithDataProvider</span>(providerRef);</span><br><span class="line">    <span class="keyword">if</span> (! <span class="built_in">CTFontManagerRegisterGraphicsFont</span>(font, &amp;error))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//注册失败</span></span><br><span class="line">        <span class="built_in">CFStringRef</span> errorDescription = <span class="built_in">CFErrorCopyDescription</span>(error);</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Failed to load font: %@"</span>, errorDescription);</span><br><span class="line">        <span class="built_in">CFRelease</span>(errorDescription);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(font);</span><br><span class="line">    <span class="built_in">CFRelease</span>(providerRef);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要先引入<code>#import &lt;CoreText/CoreText.h&gt;</code>，<code>CoreText</code>框架</p>
<ul>
<li><strong>判断字体是否加载</strong></li>
</ul>
<p>在使用字体文件前最好是先判断字体是否已经被加载过了，判断方式如下：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isFontDownloaded:(<span class="built_in">NSString</span> *)fontName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">UIFont</span>* aFont = [<span class="built_in">UIFont</span> fontWithName:fontName size:<span class="number">12.0</span>];</span><br><span class="line">    <span class="built_in">BOOL</span> isDownloaded = (aFont &amp;&amp; ([aFont.fontName compare:fontName] == <span class="built_in">NSOrderedSame</span> || [aFont.familyName compare:fontName] == <span class="built_in">NSOrderedSame</span>));</span><br><span class="line">    <span class="keyword">return</span> isDownloaded;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>其他说明</strong></li>
</ul>
<p>经测试注册过的字体在应用关闭后下次开启应用，判断字体是否加载时返回为<code>NO</code>，为了保证正常使用需要每次启动应用的时候先遍历一遍字体文件夹将里面的字体文件都再次注册一遍即可。参考代码如下:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册fonts目录下面的所有字体文件</span></span><br><span class="line"><span class="built_in">NSArray</span> *ary = [[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:<span class="keyword">self</span>.downloadPath error:<span class="literal">nil</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *p1 <span class="keyword">in</span> ary)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">NSString</span> *t1 = [<span class="keyword">self</span>.downloadPath stringByAppendingPathComponent:p1];</span><br><span class="line">	<span class="built_in">NSArray</span> *ary1 = [[<span class="built_in">NSFileManager</span> defaultManager] contentsOfDirectoryAtPath:t1 error:<span class="literal">nil</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">NSString</span> *p1 <span class="keyword">in</span> ary1)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">NSString</span> *t2 = [t1 stringByAppendingPathComponent:p1];</span><br><span class="line">		<span class="keyword">if</span>([t2 rangeOfString:<span class="string">@".ttf"</span>].location != <span class="built_in">NSNotFound</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			[<span class="keyword">self</span> registerFont:t2];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上就是对使用第三方字体的方法的介绍。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.devzeng.com/#blog" target="_blank" rel="noopener">曾静的技术博客</a>：<a href="http://blog.devzeng.com/blog/using-custom-font-in-ios.html" target="_blank" rel="noopener">在iOS开发中使用自定义字体</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Font</tag>
        <tag>第三方</tag>
        <tag>字体</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS UIView和CALayer</title>
    <url>/2017/05/08/view-and-layer/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 iOS 中，所有的 view 都是由一个底层的 layer 来驱动的。view 和它的 layer 之间有着紧密的联系，view 其实直接从 layer 对象中获取了绝大多数它所需要的数据。layer侧重于图形的显示，而view相当于layer的管理者。本文将从几个不同方面来比较view和layer的区别和联系。</p>
<a id="more"></a>
<h2 id="响应事件"><a href="#响应事件" class="headerlink" title="响应事件"></a>响应事件</h2><p>UIView的定义：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NS_CLASS_AVAILABLE_IOS</span>(<span class="number">2</span>_0) <span class="class"><span class="keyword">@interface</span> <span class="title">UIView</span> : <span class="title">UIResponder</span> &lt;<span class="title">NSCoding</span>, <span class="title">UIAppearance</span>, <span class="title">UIAppearanceContainer</span>, <span class="title">UIDynamicItem</span>, <span class="title">UITraitEnvironment</span>, <span class="title">UICoordinateSpace</span>, <span class="title">UIFocusItem</span>, <span class="title">CALayerDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>CALayer的定义：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CA_CLASS_AVAILABLE</span> (<span class="number">10.5</span>, <span class="number">2.0</span>, <span class="number">9.0</span>, <span class="number">2.0</span>)</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">CALayer</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCoding</span>, <span class="title">CAMediaTiming</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从UIView和CALayer的定义可以看出UIView是继承于UIResponder，而CALayer是继承于NSObject。在iOS中，UIKit使用UIResponder作为响应对象，来响应系统传递过来的事件并进行处理。所以UIView可以响应事件，而CALyer则不能响应事件。</p>
<h2 id="初始化和Frame"><a href="#初始化和Frame" class="headerlink" title="初始化和Frame"></a>初始化和Frame</h2><p>一个 Layer 的 frame 是由它的 anchorPoint,position,bounds,和 transform 共同决定的，而一个 View 的 frame 只是简单的返回 Layer的 frame，同样 View 的 center和 bounds 也是返回 Layer 的一些属性。我在另一篇<a href="http://www.cocoachina.com/ios/20150828/13244.html" target="_blank" rel="noopener">文章</a>中看到笔者自定义了view和layer做了实验来做测试，为了一探究竟我也做了类似的测试。<br>自定义两个类MMView和MMLayer分别集成UIView和CALyer。<br>在MMView中重写以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MMView init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass&#123;</span><br><span class="line">    <span class="keyword">return</span> [MMLayer <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setCenter:(<span class="built_in">CGPoint</span>)center&#123;</span><br><span class="line">    [<span class="keyword">super</span> setCenter:center];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBounds:(<span class="built_in">CGRect</span>)bounds&#123;</span><br><span class="line">    [<span class="keyword">super</span> setBounds:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在MMLayer中重写以下方法：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; MMLayer init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (Class)layerClass&#123;</span><br><span class="line">    <span class="keyword">return</span> [MMLayer <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setFrame:(<span class="built_in">CGRect</span>)frame&#123;</span><br><span class="line">    [<span class="keyword">super</span> setFrame:frame];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setPosition:(<span class="built_in">CGPoint</span>)position&#123;</span><br><span class="line">    [<span class="keyword">super</span> setPosition:position];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setBounds:(<span class="built_in">CGRect</span>)bounds&#123;</span><br><span class="line">    [<span class="keyword">super</span> setBounds:bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在两个类的初始化方法中分别打断点然后调用，结果如下：</p>
<img src="/2017/05/08/view-and-layer/initbreakpoint.png">
<p>我们发现在创建view的时候会先调用<code>- [MMLayer init]</code>，然后调用<code>- [UIView _createLayerWithFrame]</code>来创建layer。</p>
<p>如果在创建 View 的时候，在 Layer 和 View 中Frame 相关的所有方法中都加上断点，可以看到大致如下的调用顺序如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[MMLayer setBounds:];</span><br><span class="line">[MMView setFrame:];</span><br><span class="line">[MMLayer setFrame:];</span><br><span class="line">[MMLayer setPosetion:];</span><br><span class="line">[MMLayer setBounds:];</span><br></pre></td></tr></table></figure>
<p>从调用顺序可以发现在创建的过程只有调用了 Layer 的设置尺寸和位置的然而并没有调用View 的 SetCenter 和 SetBounds 方法。</p>
<p>如果修改了 view的 bounds.size 或者 bounds.origin 的时候也只会调用上边 Layer的一些方法。所以我们可以做如下猜测：<strong>View 的 Center 和 Bounds 只是直接返回layer 对应的 Position 和 Bounds.</strong></p>
<h2 id="内容管理和绘制"><a href="#内容管理和绘制" class="headerlink" title="内容管理和绘制"></a>内容管理和绘制</h2><p>UIView主要是对显示内容的管理，而CALayer主要是对显示的绘制</p>
<p>分别重写UIView的drawRect和CALayer的display方法<br>在MMView中重写drawRect：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)drawRect:(<span class="built_in">CGRect</span>)rect&#123;</span><br><span class="line">    [<span class="keyword">super</span> drawRect:rect];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在MMLayer中重写display：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)display&#123;</span><br><span class="line">    [<span class="keyword">super</span> display];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在drawRect方法中打断点并调用得到如下结果：<br><img src="/2017/05/08/view-and-layer/drawRectbreakpoint.png"></p>
<p>可以看到 UIView 是 CALayer 的CALayerDelegate，由此可以猜测是在代理方法内部<code>[UIView(CALayerDelegate) drawLayer:inContext]</code>调用 UIView 的<code>drawRect</code>方法，从而绘制出了 UIView 的内容。</p>
<h2 id="隐式动画"><a href="#隐式动画" class="headerlink" title="隐式动画"></a>隐式动画</h2><p>每个view都有一个layer，但是也有一些不依附view单独存在的layer，如CAShapelayer。它们不需要附加到 view 上就可以在屏幕上显示内容。<br>基本上你改变一个单独的 layer 的任何属性的时候，都会触发一个从旧的值过渡到新值的简单动画（这就是所谓的隐式动画）。然而，如果你改变的是 view 中 layer 的同一个属性，它只会从这一帧直接跳变到下一帧。尽管两种情况中都有 layer，但是当 layer 附加在 view 上时，它的默认的隐式动画的 layer 行为就不起作用了。</p>
<p>在 Core Animation 编程指南的 “How to Animate Layer-Backed Views” 中，对为什么会这样做出了一个解释：</p>
<p>UIView默认情况下禁止了layer动画，但是在 animation block 中又重新启用了它们。</p>
<p>是因为任何可动画的 layer 属性改变时，layer 都会寻找并运行合适的 action来实行这个改变。在 Core Animation 的专业术语中就把这样的动画统称为动作 (action，或者 CAAction)。</p>
<p>layer 通过向它的 delegate 发送actionForLayer:forKey: 消息来询问提供一个对应属性变化的 action。delegate 可以通过返回以下三者之一来进行响应：</p>
<ol>
<li>它可以返回一个动作对象，这种情况下 layer 将使用这个动作。</li>
<li>它可以返回一个 nil， 这样 layer 就会到其他地方继续寻找。</li>
<li>它可以返回一个 NSNull 对象，告诉 layer 这里不需要执行一个动作，搜索也会就此停止。</li>
</ol>
<p>当 layer 在背后支持一个 view 的时候，view 就是它的 delegate。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint</p>
</li>
<li><p>在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容取决于内部的 CALayer 的 display</p>
</li>
<li><p>CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)</p>
</li>
<li><p>layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer</p>
</li>
<li><p>两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</p>
</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cocoachina.com/ios/20150828/13244.html" target="_blank" rel="noopener">详解 CALayer 和 UIView 的区别和联系</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>UIView</tag>
        <tag>CALayer</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS资源推荐</title>
    <url>/2016/11/09/iOS-Blog-List/</url>
    <content><![CDATA[<p><strong><a href="https://github.com/tangqiaoboy/iOSBlogCN" target="_blank" rel="noopener">iOS技术博客列表</a></strong><br>由唐巧维护在github上，收集了很多优秀的中文iOS技术博客。</p>
<p><strong><a href="https://github.com/Tim9Liu9/TimLiu-iOS" target="_blank" rel="noopener">iOS常用第三方库</a></strong><br>收集了iOS常用的第三方库以及其他资源</p>
<p><strong><a href="https://github.com/MobDevGroup/iOSDevelopmentTutorial" target="_blank" rel="noopener">iOS开发资源汇总整理</a></strong><br>收集了iOS开发的文档，视频以及其他综合信息</p>
<p><strong><a href="https://github.com/leecade/ios-dev-flow" target="_blank" rel="noopener">iOS 开发流程笔记</a></strong><br>收集了iOS证书，调试，上架等知识</p>
<a id="more"></a>
<p><strong><a href="https://github.com/ipader/SwiftGuide" target="_blank" rel="noopener">Swift 语言指南</a></strong><br>汇集了Swift语言主流学习资源</p>
<p><strong><a href="https://github.com/reactnativecn/react-native-guide" target="_blank" rel="noopener">React-Native学习指南</a></strong><br>丰富的RN学习资源</p>
<p><strong><a href="http://blog.fir.im/fir_im_weekly151211/" target="_blank" rel="noopener">fir.im Weekly 94个iOS开发资源推荐</a></strong><br>优秀资源推荐，包含工具，测试，设计等。</p>
<p><strong><a href="https://github.com/ChenYilong/iOSInterviewQuestions" target="_blank" rel="noopener">招聘一个靠谱的iOS</a></strong><br>iOS基础知识的考察和总结</p>
<p>以上内容会持续更新…</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Blog</tag>
        <tag>技术</tag>
        <tag>博客</tag>
        <tag>资源</tag>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative组件的生命周期</title>
    <url>/2016/11/09/ReactNative-LifeCycle/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>就像 iOS 开发中的 ViewController 一样，React Native（RN） 中的组件也有生命周期（Lifecycle）。所谓生命周期，就是一个对象从开始生成到最后消亡所经历的状态，理解生命周期，是合理开发的关键。<br><a id="more"></a></p>
<h2 id="周期阶段"><a href="#周期阶段" class="headerlink" title="周期阶段"></a>周期阶段</h2><p>RN 组件的生命周期整理如下图：<br><img src="/2016/11/09/ReactNative-LifeCycle/lifecycle.jpg"></p>
<p>组件生命周期大致分为三个阶</p>
<ul>
<li><p>第一阶段：是组件第一次绘制阶段，如图中的上面虚线框内，在这里完成了组件的加载和初始化</p>
</li>
<li><p>第二阶段：是组件在运行和交互阶段，如图中左下角虚线框，这个阶段组件可以处理用户交互，或者接收事件更新界面</p>
</li>
<li><p>第三阶段：是组件卸载消亡的阶段，如图中右下角的虚线框中，这里做一些组件的清理工作。</p>
</li>
</ul>
<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p><strong>getDefaultProps</strong><br>在组件类创建的时候调用一次，然后返回值被缓存下来。全局调用一次，所有实例共享。</p>
<p><strong>getInitialState</strong><br>在组件挂载之前调用一次。返回值将会作为 this.state 的初始值。</p>
<p><strong>componentWillMount </strong><br>在初始化渲染执行之前立刻调用,并且只会调用一次。<br>这个函数调用时机是在组件创建，并初始化了状态之后，在第一次绘制 render() 之前。可以在这里做一些业务初始化操作，也可以设置组件状态。这个函数在整个生命周期中只被调用一次。</p>
<p><strong>render</strong><br>这个方法是必须的，对视图进行渲染，你也可以返回 null 或者 false 来表明不需要渲染任何东西</p>
<p><strong>componentDidMount</strong><br>在初始化渲染执行之后立刻调用一次，只会调用一次。<br>这个函数调用的时候，其虚拟 DOM 已经构建完成，你可以在这个函数开始获取其中的元素或者子组件了。需要注意的是，RN 框架是先调用子组件的 componentDidMount()，然后调用父组件的函数。从这个函数开始，就可以和 JS 其他框架交互了，例如设置计时 setTimeout 或者 setInterval，或者发起网络请求。这个函数也是只被调用一次。这个函数之后，就进入了稳定运行状态，等待事件触发。</p>
<p><strong>componentWillReceiveProps</strong><br>在组件接收到新的 props 的时候调用，也就是父组件修改子组件的属性时触发。在初始化渲染的时候，该方法不会调用。可以用于更新 state 来响应某个 prop 的改变。</p>
<p><strong>shouldComponentUpdate</strong><br>当组件接收到新的属性和状态改变的话，都会触发调用 shouldComponentUpdate(…)<br>默认情况下，这个函数永远返回 true 用来保证数据变化的时候 UI 能够同步更新。在大型项目中，你可以自己重载这个函数，通过检查变化前后属性和状态，来决定 UI 是否需要更新，能有效提高应用性能。</p>
<p><strong>componentWillUpdate</strong><br>如果组件状态或者属性改变，并且上面的 shouldComponentUpdate(…) 返回为 true，就会开始准更新组件，并调用 componentWillUpdate()</p>
<p><strong>componentDidUpdate</strong><br>调用了 render() 更新完成界面之后，会调用 componentDidUpdate() 来得到通知</p>
<p><strong>componentWillUnmount</strong><br>当组件要被从界面上移除的时候，就会调用 componentWillUnmount()<br>在这个函数中，可以做一些组件相关的清理工作，例如取消计时器、网络请求等</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是ReactNative组件的生命周期，由于刚接触不久，有些地方可能写的不太详细，后期会更新。<br>另外推荐一个学习ReactNative的地方<a href="https://github.com/leroyli/react-native-guide" target="_blank" rel="noopener">React-Native学习指南</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.race604.com/react-native-component-lifecycle/#" target="_blank" rel="noopener">React Native 中组件的生命周期</a><br><a href="http://www.reactnativeexpress.com/lifecycle_api" target="_blank" rel="noopener">Life Cycle API</a></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>ReactNative</tag>
        <tag>组件</tag>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS RunLoop详解</title>
    <url>/2016/11/09/iOS-RunLoop/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>RunLoop 是 iOS 和 OSX 开发中非常基础的一个概念，我们平常开发中也会经常用到RunLoop,但很多时候我们使用RunLoop都是一知半解的。这篇文章将从 CFRunLoop 的源码入手，介绍 RunLoop 的概念以及底层实现原理。<br><a id="more"></a></p>
<h2 id="RunLoop-的概念"><a href="#RunLoop-的概念" class="headerlink" title="RunLoop 的概念"></a>RunLoop 的概念</h2><p>一般来讲，一个线程一次只能执行一个任务，执行完成后线程就会退出。如果我们需要一个机制，让线程能随时处理事件但并不退出，通常的代码逻辑是这样的：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">function loop() &#123;</span><br><span class="line">    initialize();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var message = get_next_message();</span><br><span class="line">        process_message(message);</span><br><span class="line">    &#125; <span class="keyword">while</span> (message != quit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种模型通常被称作 Event Loop。 Event Loop 在很多系统和框架里都有实现，比如 Node.js 的事件处理，比如 Windows 程序的消息循环，再比如 OSX/iOS 里的 RunLoop。实现这种模型的关键点在于：如何管理事件/消息，如何让线程在没有处理消息时休眠以避免资源占用、在有消息到来时立刻被唤醒。</p>
<p>所以，RunLoop 实际上就是一个对象，这个对象管理了其需要处理的事件和消息，并提供了一个入口函数来执行上面 Event Loop 的逻辑。线程执行了这个函数后，就会一直处于这个函数内部 “接受消息-&gt;等待-&gt;处理” 的循环中，直到这个循环结束（比如传入 quit 的消息），函数返回</p>
<p>OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。<br>CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。</p>
<p>NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。</p>
<h2 id="RunLoop-与线程的关系"><a href="#RunLoop-与线程的关系" class="headerlink" title="RunLoop 与线程的关系"></a>RunLoop 与线程的关系</h2><p>首先，iOS 开发中能遇到两个线程对象: pthread_t 和 NSThread。过去苹果有份文档标明了 NSThread 只是 pthread_t 的封装，但那份文档已经失效了，现在它们也有可能都是直接包装自最底层的 mach thread。苹果并没有提供这两个对象相互转换的接口，但不管怎么样，可以肯定的是 pthread_t 和 NSThread 是一一对应的。比如，你可以通过 pthread_main_thread_np() 或 [NSThread mainThread] 来获取主线程；也可以通过 pthread_self() 或 [NSThread currentThread] 来获取当前线程。CFRunLoop 是基于 pthread 来管理的。</p>
<p>苹果不允许直接创建 RunLoop，它只提供了两个自动获取的函数：CFRunLoopGetMain() 和 CFRunLoopGetCurrent()。 这两个函数内部的逻辑大概是下面这样:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 全局的Dictionary，key 是 pthread_t， value 是 CFRunLoopRef</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFMutableDictionaryRef</span> loopsDic;</span><br><span class="line"><span class="comment">/// 访问 loopsDic 时的锁</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">CFSpinLock_t</span> loopsLock;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 获取一个 pthread 对应的 RunLoop。</span></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> _CFRunLoopGet(pthread_t thread) &#123;</span><br><span class="line">    OSSpinLockLock(&amp;loopsLock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loopsDic) &#123;</span><br><span class="line">        <span class="comment">// 第一次进入时，初始化全局Dic，并先为主线程创建一个 RunLoop。</span></span><br><span class="line">        loopsDic = <span class="built_in">CFDictionaryCreateMutable</span>();</span><br><span class="line">        <span class="built_in">CFRunLoopRef</span> mainLoop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, pthread_main_thread_np(), mainLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 直接从 Dictionary 里获取。</span></span><br><span class="line">    <span class="built_in">CFRunLoopRef</span> loop = <span class="built_in">CFDictionaryGetValue</span>(loopsDic, thread));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!loop) &#123;</span><br><span class="line">        <span class="comment">/// 取不到时，创建一个</span></span><br><span class="line">        loop = _CFRunLoopCreate();</span><br><span class="line">        <span class="built_in">CFDictionarySetValue</span>(loopsDic, thread, loop);</span><br><span class="line">        <span class="comment">/// 注册一个回调，当线程销毁时，顺便也销毁其对应的 RunLoop。</span></span><br><span class="line">        _CFSetTSD(..., thread, loop, __CFFinalizeRunLoop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OSSpinLockUnLock(&amp;loopsLock);</span><br><span class="line">    <span class="keyword">return</span> loop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetMain</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_main_thread_np());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRunLoopRef</span> <span class="built_in">CFRunLoopGetCurrent</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> _CFRunLoopGet(pthread_self());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个全局的 Dictionary 里。线程刚创建时并没有 RunLoop，如果你不主动获取，那它一直都不会有。RunLoop 的创建是发生在第一次获取时，RunLoop 的销毁是发生在线程结束时。你只能在一个线程的内部获取其 RunLoop（主线程除外）。</p>
<h2 id="RunLoop-对外的接口"><a href="#RunLoop-对外的接口" class="headerlink" title="RunLoop 对外的接口"></a>RunLoop 对外的接口</h2><p>在 CoreFoundation 里面关于 RunLoop 有5个类</p>
<p><strong>- CFRunLoopRef </strong><br><strong>- CFRunLoopModeRef </strong><br><strong>- CFRunLoopSourceRef </strong><br><strong>- CFRunLoopTimerRef </strong><br><strong>- CFRunLoopObserverRef</strong></p>
<p>其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:<br><img src="/2016/11/09/iOS-RunLoop/RunLoop.png"></p>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。</p>
<p><strong>CFRunLoopSourceRef </strong>是事件产生的地方。Source有两个版本：Source0 和 Source1。</p>
<ul>
<li>Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。</li>
<li>Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。</li>
</ul>
<p><strong>CFRunLoopTimerRef </strong>是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。</p>
<p><strong>CFRunLoopObserverRef </strong>是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">CF_OPTIONS</span>(<span class="built_in">CFOptionFlags</span>, <span class="built_in">CFRunLoopActivity</span>) &#123;</span><br><span class="line">    kCFRunLoopEntry         = (<span class="number">1</span>UL &lt;&lt; <span class="number">0</span>), <span class="comment">// 即将进入Loop</span></span><br><span class="line">    kCFRunLoopBeforeTimers  = (<span class="number">1</span>UL &lt;&lt; <span class="number">1</span>), <span class="comment">// 即将处理 Timer</span></span><br><span class="line">    kCFRunLoopBeforeSources = (<span class="number">1</span>UL &lt;&lt; <span class="number">2</span>), <span class="comment">// 即将处理 Source</span></span><br><span class="line">    kCFRunLoopBeforeWaiting = (<span class="number">1</span>UL &lt;&lt; <span class="number">5</span>), <span class="comment">// 即将进入休眠</span></span><br><span class="line">    kCFRunLoopAfterWaiting  = (<span class="number">1</span>UL &lt;&lt; <span class="number">6</span>), <span class="comment">// 刚从休眠中唤醒</span></span><br><span class="line">    kCFRunLoopExit          = (<span class="number">1</span>UL &lt;&lt; <span class="number">7</span>), <span class="comment">// 即将退出Loop</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。</p>
<h2 id="RunLoop-的-Mode"><a href="#RunLoop-的-Mode" class="headerlink" title="RunLoop 的 Mode"></a>RunLoop 的 Mode</h2><p>CFRunLoopMode 和 CFRunLoop 的结构大致如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;            <span class="comment">// Mode Name, 例如 @"kCFRunLoopDefaultMode"</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;    <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers; <span class="comment">// Array</span></span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;    <span class="comment">// Array</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;     <span class="comment">// Set</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems; <span class="comment">// Set&lt;Source/Observer/Timer&gt;</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;    <span class="comment">// Current Runloop Mode</span></span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;           <span class="comment">// Set</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里有个概念叫 “CommonModes”：一个 Mode 可以将自己标记为”Common”属性（通过将其 ModeName 添加到 RunLoop 的 “commonModes” 中）。每当 RunLoop 的内容发生变化时，RunLoop 都会自动将 _commonModeItems 里的 Source/Observer/Timer 同步到具有 “Common” 标记的所有Mode里。</p>
<p>使用时有以下几种Mode：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSDefalutRunLoopMode</span>      默认状态.空闲状态</span><br><span class="line"><span class="built_in">UITrackingRunLoopMode</span>     滑动ScrollView</span><br><span class="line"><span class="built_in">UIInitializationRunLoopMode</span>    私有,App启动时</span><br><span class="line"><span class="built_in">NSRunLoopCommonModes</span>     默认包括上面第一和第二</span><br></pre></td></tr></table></figure></p>
<p>在使用过程中场景最多就是UITrackingRunLoopMode 与 NSTimer<br>默认情况下NSTimer被加入NSDefalutRunLoopMode<br>如果想NSTimer受到组件或者动画影响 添加到NSRunLoopCommonModes</p>
<p>应用场景举例：主线程的 RunLoop 里有两个预置的 Mode：kCFRunLoopDefaultMode 和 UITrackingRunLoopMode。这两个 Mode 都已经被标记为”Common”属性。DefaultMode 是 App 平时所处的状态，TrackingRunLoopMode 是追踪 ScrollView 滑动时的状态。当你创建一个 Timer 并加到 DefaultMode 时，Timer 会得到重复回调，但此时滑动一个TableView时，RunLoop 会将 mode 切换为 TrackingRunLoopMode，这时 Timer 就不会被回调，并且也不会影响到滑动操作</p>
<p>有时你需要一个 Timer，在两个 Mode 中都能得到回调，一种办法就是将这个 Timer 分别加入这两个 Mode。还有一种方式，就是将 Timer 加入到顶层的 RunLoop 的 “commonModeItems” 中。”commonModeItems” 被 RunLoop 自动更新到所有具有”Common”属性的 Mode 里去</p>
<p>CFRunLoop对外暴露的管理 Mode 接口只有下面2个:<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddCommonMode</span>(<span class="built_in">CFRunLoopRef</span> runloop, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, ...);</span><br></pre></td></tr></table></figure></p>
<p>Mode 暴露的管理 mode item 的接口有下面几个：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CFRunLoopAddSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopAddTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveSource</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopSourceRef</span> source, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveObserver</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopObserverRef</span> observer, <span class="built_in">CFStringRef</span> modeName);</span><br><span class="line"><span class="built_in">CFRunLoopRemoveTimer</span>(<span class="built_in">CFRunLoopRef</span> rl, <span class="built_in">CFRunLoopTimerRef</span> timer, <span class="built_in">CFStringRef</span> mode);</span><br></pre></td></tr></table></figure>
<p>你只能通过 mode name 来操作内部的 mode，当你传入一个新的 mode name 但 RunLoop 内部没有对应 mode 时，RunLoop会自动帮你创建对应的 CFRunLoopModeRef。对于一个 RunLoop 来说，其内部的 mode 只能增加不能删除。</p>
<p>苹果公开提供的 Mode 有两个：kCFRunLoopDefaultMode (NSDefaultRunLoopMode) 和 UITrackingRunLoopMode，你可以用这两个 Mode Name 来操作其对应的 Mode。</p>
<p>同时苹果还提供了一个操作 Common 标记的字符串：kCFRunLoopCommonModes (NSRunLoopCommonModes)，你可以用这个字符串来操作 Common Items，或标记一个 Mode 为 “Common”。使用时注意区分这个字符串和其他 mode name。</p>
<h2 id="RunLoop-的内部逻辑"><a href="#RunLoop-的内部逻辑" class="headerlink" title="RunLoop 的内部逻辑"></a>RunLoop 的内部逻辑</h2><p>根据苹果在<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW23" target="_blank" rel="noopener">文档</a>里的说明，RunLoop 内部的逻辑大致如下:</p>
<img src="/2016/11/09/iOS-RunLoop/RunLoop1.png">
<p>其内部代码整理如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 用DefaultMode启动</span></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">CFRunLoopRun</span>(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), kCFRunLoopDefaultMode, <span class="number">1.0e10</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用指定的Mode启动，允许设置RunLoop超时时间</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunInMode</span>(<span class="built_in">CFStringRef</span> modeName, <span class="built_in">CFTimeInterval</span> seconds, Boolean stopAfterHandle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">CFRunLoopRunSpecific</span>(<span class="built_in">CFRunLoopGetCurrent</span>(), modeName, seconds, returnAfterSourceHandled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// RunLoop的实现</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">CFRunLoopRunSpecific</span>(runloop, modeName, seconds, stopAfterHandle) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 首先根据modeName找到对应mode</span></span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> currentMode = __CFRunLoopFindMode(runloop, modeName, <span class="literal">false</span>);</span><br><span class="line">    <span class="comment">/// 如果mode里没有source/timer/observer, 直接返回。</span></span><br><span class="line">    <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(currentMode)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 1. 通知 Observers: RunLoop 即将进入 loop。</span></span><br><span class="line">    __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopEntry);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 内部函数，进入loop</span></span><br><span class="line">    __CFRunLoopRun(runloop, currentMode, seconds, returnAfterSourceHandled) &#123;</span><br><span class="line"></span><br><span class="line">        Boolean sourceHandledThisLoop = <span class="literal">NO</span>;</span><br><span class="line">        <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 2. 通知 Observers: RunLoop 即将触发 Timer 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeTimers);</span><br><span class="line">            <span class="comment">/// 3. 通知 Observers: RunLoop 即将触发 Source0 (非port) 回调。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeSources);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 4. RunLoop 触发 Source0 (非port) 回调。</span></span><br><span class="line">            sourceHandledThisLoop = __CFRunLoopDoSources0(runloop, currentMode, stopAfterHandle);</span><br><span class="line">            <span class="comment">/// 执行被加入的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 5. 如果有 Source1 (基于port) 处于 ready 状态，直接处理这个 Source1 然后跳转去处理消息。</span></span><br><span class="line">            <span class="keyword">if</span> (__Source0DidDispatchPortLastTime) &#123;</span><br><span class="line">                Boolean hasMsg = __CFRunLoopServiceMachPort(dispatchPort, &amp;msg)</span><br><span class="line">                <span class="keyword">if</span> (hasMsg) <span class="keyword">goto</span> handle_msg;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 通知 Observers: RunLoop 的线程即将进入休眠(sleep)。</span></span><br><span class="line">            <span class="keyword">if</span> (!sourceHandledThisLoop) &#123;</span><br><span class="line">                __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopBeforeWaiting);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 7. 调用 mach_msg 等待接受 mach_port 的消息。线程将进入休眠, 直到被下面某一个事件唤醒。</span></span><br><span class="line">            <span class="comment">/// • 一个基于 port 的Source 的事件。</span></span><br><span class="line">            <span class="comment">/// • 一个 Timer 到时间了</span></span><br><span class="line">            <span class="comment">/// • RunLoop 自身的超时时间到了</span></span><br><span class="line">            <span class="comment">/// • 被其他什么调用者手动唤醒</span></span><br><span class="line">            __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="keyword">sizeof</span>(msg_buffer), &amp;livePort) &#123;</span><br><span class="line">                mach_msg(msg, MACH_RCV_MSG, port); <span class="comment">// thread wait for receive msg</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 8. 通知 Observers: RunLoop 的线程刚刚被唤醒了。</span></span><br><span class="line">            __CFRunLoopDoObservers(runloop, currentMode, kCFRunLoopAfterWaiting);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 收到消息，处理消息。</span></span><br><span class="line">            handle_msg:</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.1 如果一个 Timer 到时间了，触发这个Timer的回调。</span></span><br><span class="line">            <span class="keyword">if</span> (msg_is_timer) &#123;</span><br><span class="line">                __CFRunLoopDoTimers(runloop, currentMode, mach_absolute_time())</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.2 如果有dispatch到main_queue的block，执行block。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (msg_is_dispatch) &#123;</span><br><span class="line">                __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 9.3 如果一个 Source1 (基于port) 发出事件了，处理这个事件</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">CFRunLoopSourceRef</span> source1 = __CFRunLoopModeFindSourceForMachPort(runloop, currentMode, livePort);</span><br><span class="line">                sourceHandledThisLoop = __CFRunLoopDoSource1(runloop, currentMode, source1, msg);</span><br><span class="line">                <span class="keyword">if</span> (sourceHandledThisLoop) &#123;</span><br><span class="line">                    mach_msg(reply, MACH_SEND_MSG, reply);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 执行加入到Loop的block</span></span><br><span class="line">            __CFRunLoopDoBlocks(runloop, currentMode);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123;</span><br><span class="line">                <span class="comment">/// 进入loop时参数说处理完事件就返回。</span></span><br><span class="line">                retVal = kCFRunLoopRunHandledSource;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">                <span class="comment">/// 超出传入参数标记的超时时间了</span></span><br><span class="line">                retVal = kCFRunLoopRunTimedOut;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopIsStopped(runloop)) &#123;</span><br><span class="line">                <span class="comment">/// 被外部调用者强制停止了</span></span><br><span class="line">                retVal = kCFRunLoopRunStopped;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (__CFRunLoopModeIsEmpty(runloop, currentMode)) &#123;</span><br><span class="line">                <span class="comment">/// source/timer/observer一个都没有了</span></span><br><span class="line">                retVal = kCFRunLoopRunFinished;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/// 如果没超时，mode里没空，loop也没被停止，那继续loop。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (retVal == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 10. 通知 Observers: RunLoop 即将退出。</span></span><br><span class="line">    __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上 RunLoop 就是这样一个函数，其内部是一个 do-while 循环。当你调用 CFRunLoopRun() 时，线程就会一直停留在这个循环里；直到超时或被手动停止，该函数才会返回。</p>
<h2 id="RunLoop-的底层实现"><a href="#RunLoop-的底层实现" class="headerlink" title="RunLoop 的底层实现"></a>RunLoop 的底层实现</h2><p>从上面代码可以看到，RunLoop 的核心是基于 mach port 的，其进入休眠时调用的函数是 mach_msg()。为了解释这个逻辑，下面稍微介绍一下 OSX/iOS 的系统架构。<br><img src="/2016/11/09/iOS-RunLoop/RunLoop2.png"></p>
<p>苹果官方将整个系统大致划分为上述4个层次：<br>应用层包括用户能接触到的图形应用，例如 Spotlight、Aqua、SpringBoard 等。<br>应用框架层即开发人员接触到的 Cocoa 等框架。<br>核心框架层包括各种核心框架、OpenGL 等内容。<br>Darwin 即操作系统的核心，包括系统内核、驱动、Shell 等内容，这一层是开源的，其所有源码都可以在 opensource.apple.com 里找到。</p>
<p>我们在深入看一下 Darwin 这个核心的架构：<br><img src="/2016/11/09/iOS-RunLoop/RunLoop3.png"></p>
<p>其中，在硬件层上面的三个组成部分：Mach、BSD、IOKit (还包括一些上面没标注的内容)，共同组成了 XNU 内核。<br>XNU 内核的内环被称作 Mach，其作为一个微内核，仅提供了诸如处理器调度、IPC (进程间通信)等非常少量的基础服务。<br>BSD 层可以看作围绕 Mach 层的一个外环，其提供了诸如进程管理、文件系统和网络等功能。<br>IOKit 层是为设备驱动提供了一个面向对象(C++)的一个框架。</p>
<p>Mach 本身提供的 API 非常有限，而且苹果也不鼓励使用 Mach 的 API，但是这些API非常基础，如果没有这些API的话，其他任何工作都无法实施。在 Mach 中，所有的东西都是通过自己的对象实现的，进程、线程和虚拟内存都被称为”对象”。和其他架构不同， Mach 的对象间不能直接调用，只能通过消息传递的方式实现对象间的通信。”消息”是 Mach 中最基础的概念，消息在两个端口 (port) 之间传递，这就是 Mach 的 IPC (进程间通信) 的核心。</p>
<p>Mach 的消息定义是在 &lt;mach/message.h&gt; 头文件的，很简单：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_header_t header;</span><br><span class="line">  mach_msg_body_t body;</span><br><span class="line">&#125; mach_msg_base_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  mach_msg_bits_t msgh_bits;</span><br><span class="line">  mach_msg_size_t msgh_size;</span><br><span class="line">  mach_port_t msgh_remote_port;</span><br><span class="line">  mach_port_t msgh_local_port;</span><br><span class="line">  mach_port_name_t msgh_voucher_port;</span><br><span class="line">  mach_msg_id_t msgh_id;</span><br><span class="line">&#125; mach_msg_header_t;</span><br></pre></td></tr></table></figure></p>
<p>一条 Mach 消息实际上就是一个二进制数据包 (BLOB)，其头部定义了当前端口 local_port 和目标端口 remote_port，<br>发送和接受消息是通过同一个 API 进行的，其 option 标记了消息传递的方向：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">mach_msg_return_t mach_msg(</span><br><span class="line">            mach_msg_header_t *msg,</span><br><span class="line">            mach_msg_option_t option,</span><br><span class="line">            mach_msg_size_t send_size,</span><br><span class="line">            mach_msg_size_t rcv_size,</span><br><span class="line">            mach_port_name_t rcv_name,</span><br><span class="line">            mach_msg_timeout_t timeout,</span><br><span class="line">            mach_port_name_t notify);</span><br></pre></td></tr></table></figure>
<p>为了实现消息的发送和接收，mach_msg() 函数实际上是调用了一个 Mach 陷阱 (trap)，即函数mach_msg_trap()，陷阱这个概念在 Mach 中等同于系统调用。当你在用户态调用 mach_msg_trap() 时会触发陷阱机制，切换到内核态；内核态中内核实现的 mach_msg() 函数会完成实际的工作，如下图：</p>
<img src="/2016/11/09/iOS-RunLoop/RunLoop4.png">
<p>这些概念可以参考维基百科: <a href="https://en.wikipedia.org/wiki/System_call" target="_blank" rel="noopener">System_call</a>、<a href="https://en.wikipedia.org/wiki/Trap_(computing" target="_blank" rel="noopener">Trap_(computing)</a>)。</p>
<p>RunLoop 的核心就是一个 mach_msg() (见上面代码的第7步)，RunLoop 调用这个函数去接收消息，如果没有别人发送 port 消息过来，内核会将线程置于等待状态。例如你在模拟器里跑起一个 iOS 的 App，然后在 App 静止时点击暂停，你会看到主线程调用栈是停留在 mach_msg_trap() 这个地方。</p>
<h2 id="苹果用-RunLoop-实现的功能"><a href="#苹果用-RunLoop-实现的功能" class="headerlink" title="苹果用 RunLoop 实现的功能"></a>苹果用 RunLoop 实现的功能</h2><p><strong>- AutoreleasePool</strong></p>
<p><strong>- 事件响应</strong></p>
<p><strong>- 手势识别</strong></p>
<p><strong>- 界面更新</strong></p>
<p><strong>- 定时器</strong></p>
<p><strong>- PerformSelecter</strong></p>
<p><strong>- GCD</strong></p>
<p><strong>- 网络请求</strong></p>
<p>如果想深入了解，请移步到<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">原文</a></p>
<p>本文大量参考自ibireme的<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a>，<br>由于原文写的太好，怕以后找不到，所以就记录下来</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>ibireme；<a href="http://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="noopener">深入理解RunLoop</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的黑魔法:Method Swizzling</title>
    <url>/2016/11/09/iOS-Method-Swizzling/</url>
    <content><![CDATA[<h2 id="什么是Method-Swizzling"><a href="#什么是Method-Swizzling" class="headerlink" title="什么是Method Swizzling"></a>什么是Method Swizzling</h2><p>Objective-C对象在收到消息之后会经过消息发送系统来进行处理，该系统会查出消息对应的方法并执行其代码。那么对于给定@selector名称相对应的方法是否可以在运行期可以动态改变呢？如果能善用这个特性，则可发挥出巨大优势，因为我们可以不需要源码也不需要通过继承子类来覆写对应的方法就能改变这个类本身的功能。</p>
<p>Objective-C中确实提供了这样的操作，这就是我们这里会介绍到的Method Swizzling。在Objective-C中每个类都有一个方法列表，类的方法列表会把@selector映射到相关的方法实现之上，使得消息发送系统能够根据这个找到应该调用的方法。<br><a id="more"></a></p>
<h2 id="Method-Swizzling-的原理"><a href="#Method-Swizzling-的原理" class="headerlink" title="Method Swizzling 的原理"></a>Method Swizzling 的原理</h2><p>Method Swizzling 是一把双刃剑，使用得当可以让我们非常轻松地实现复杂的功能，而如果一旦误用，它也很可能会给我们的程序带来毁灭性的伤害。但是我们大可不必惊慌，在了解了它的实现原理后，我们就可以“信手拈来”了。</p>
<p>我们先来了解下 Objective-C 中方法 Method 的数据结构：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> method_t *Method;</span><br><span class="line"><span class="keyword">struct</span> method_t &#123;</span><br><span class="line">    SEL name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types;</span><br><span class="line">    IMP imp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        public std::binary_function&lt;<span class="keyword">const</span> method_t&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> method_t&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">bool</span> operator() (<span class="keyword">const</span> method_t&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> method_t&amp; rhs)</span><br><span class="line">        &#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本质上，它就是 struct method_t 类型的指针，所以我们重点看下结构体 method_t 的定义。在结构体 method_t 中定义了三个成员变量和一个成员函数</p>
<p><strong>name</strong>表示的是方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:) ;</p>
<p><strong>types</strong>表示的是方法的返回值和参数类型</p>
<p><strong>imp</strong>是一个函数指针，指向方法的实现；</p>
<p><strong>SortBySELAddress</strong>顾名思义，是一个根据 name 的地址对方法进行排序的函数。</p>
<p>由此，我们也可以发现 Objective-C 中的方法名是不包括参数类型的，也就是说下面两个方法在 runtime 看来就是同一个方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">NSString</span> *)string;</span><br></pre></td></tr></table></figure>
<p>而下面两个方法却是可以共存的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</span><br><span class="line">+ (<span class="keyword">void</span>)viewWillAppear:(<span class="built_in">BOOL</span>)animated;</span><br></pre></td></tr></table></figure>
<p>因为实例方法和类方法是分别保存在类对象和元类对象中的</p>
<p>原则上，方法的名称 <strong>name</strong> 和方法的实现 <strong>imp</strong> 是一一对应的，而 <strong>Method Swizzling</strong> 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>
<h2 id="Method-Swizzling-实践"><a href="#Method-Swizzling-实践" class="headerlink" title="Method Swizzling 实践"></a>Method Swizzling 实践</h2><p>首先来看看Method Swizzling相关函数</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取通过SEL获取一个方法</span></span><br><span class="line">class_getInstanceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个方法的实现</span></span><br><span class="line">method_getImplementation</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取一个OC实现的编码类型</span></span><br><span class="line">method_getTypeEncoding</span><br><span class="line"></span><br><span class="line"><span class="comment">//給方法添加实现</span></span><br><span class="line">class_addMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">//用一个方法的实现替换另一个方法的实现</span></span><br><span class="line">class_replaceMethod</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个方法的实现</span></span><br><span class="line">method_exchangeImplementations</span><br></pre></td></tr></table></figure>
<p>下面来看一个例子</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">＋ (<span class="keyword">void</span>)load&#123;</span><br><span class="line"> <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        <span class="comment">//case1: 替换实例方法</span></span><br><span class="line">        Class selfClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">        <span class="comment">//case2: 替换类方法</span></span><br><span class="line">        Class selfClass = object_getClass([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//源方法的SEL和Method</span></span><br><span class="line">        SEL oriSEL = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换方法的SEL和Method</span></span><br><span class="line">        SEL cusSEL = <span class="keyword">@selector</span>(customViewWillApper:);</span><br><span class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先尝试給源方法添加实现，这里是为了避免源方法没有实现的情况</span></span><br><span class="line">        <span class="built_in">BOOL</span> addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</span><br><span class="line">        <span class="keyword">if</span> (addSucc) &#123;</span><br><span class="line">            <span class="comment">//添加成功：将源方法的实现替换到交换方法的实现</span></span><br><span class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//添加失败：说明源方法已经有实现，直接将两个方法的实现交换即可</span></span><br><span class="line">            method_exchangeImplementations(oriMethod, cusMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>要注意的地方</strong></p>
<ol>
<li><p>在 +load 方法中实现 Method Swizzling 的逻辑.<br>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法。但是它们被调用的时机却是有差别的，+load 方法是在类被加载的时候调用的，而 +initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。此外 +load 方法还有一个非常重要的特性，那就是子类、父类和分类中的 +load 方法的实现是被区别对待的。换句话说在 Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖。综上所述，+load 方法是实现 Method Swizzling 逻辑的最佳“场所”。</p>
</li>
<li><p>方法交换应该保证唯一性和原子性<br>唯一性：应该尽可能在＋load方法中实现，这样可以保证方法一定会调用且不会出现异常。<br>原子性：使用dispatch_once来执行方法交换，这样可以保证只运行一次。</p>
</li>
<li><p>方法名必须不能产生冲突</p>
</li>
<li><p>尽量少用方法交换<br>虽然方法交换可以让我们高效地解决问题，但是如果处理不好，可能会导致一些莫名其妙的bug</p>
</li>
</ol>
<h2 id="Method-Swizzling应用实例"><a href="#Method-Swizzling应用实例" class="headerlink" title="Method Swizzling应用实例"></a>Method Swizzling应用实例</h2><ul>
<li>给全局图片名称添加前缀</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImage</span> (<span class="title">Hook</span>)</span></span><br><span class="line"></span><br><span class="line">＋ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        Class selfClass = object_getClass([<span class="keyword">self</span> <span class="keyword">class</span>]);</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = <span class="keyword">@selector</span>(imageNamed:);</span><br><span class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</span><br><span class="line"></span><br><span class="line">        SEL cusSEL = <span class="keyword">@selector</span>(myImageNamed:);</span><br><span class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</span><br><span class="line">        <span class="keyword">if</span> (addSucc) &#123;</span><br><span class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(oriMethod, cusMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">＋ (<span class="built_in">UIImage</span> *)myImageNamed:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> * newName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@%@"</span>, <span class="string">@"new_"</span>, name];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> myImageNamed:newName];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在+load方法中将imageNamed和myImageNamed的实现交换了，现在的状态变成了<br>imageNamed -&gt; myImageNamed(IMP)<br>myImageNamed -&gt; imageNamed(IMP)</p>
<ul>
<li>数据统计<br>例如需要跟踪记录APP中按钮的点击次数和频率等数据</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIButton</span> (<span class="title">Hook</span>)</span></span><br><span class="line"></span><br><span class="line">＋ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line"></span><br><span class="line">        Class selfClass = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        SEL oriSEL = <span class="keyword">@selector</span>(sendAction:to:forEvent:);</span><br><span class="line">        Method oriMethod = class_getInstanceMethod(selfClass, oriSEL);</span><br><span class="line"></span><br><span class="line">        SEL cusSEL = <span class="keyword">@selector</span>(mySendAction:to:forEvent:);</span><br><span class="line">        Method cusMethod = class_getInstanceMethod(selfClass, cusSEL);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">BOOL</span> addSucc = class_addMethod(selfClass, oriSEL, method_getImplementation(cusMethod), method_getTypeEncoding(cusMethod));</span><br><span class="line">        <span class="keyword">if</span> (addSucc) &#123;</span><br><span class="line">            class_replaceMethod(selfClass, cusSEL, method_getImplementation(oriMethod), method_getTypeEncoding(oriMethod));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            method_exchangeImplementations(oriMethod, cusMethod);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">－ (<span class="keyword">void</span>)mySendAction:(SEL)action to:(<span class="keyword">id</span>)target forEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    [CountTool addClickCount];</span><br><span class="line">    [<span class="keyword">self</span> mySendAction:action to:target forEvent:event];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="Method-Swizzling方法封装"><a href="#Method-Swizzling方法封装" class="headerlink" title="Method Swizzling方法封装"></a>Method Swizzling方法封装</h2><p>如果使用的地方比较多的话，封装起来使用还是比较方便的</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">＋ (<span class="keyword">void</span>)swizzleMethods:(Class)<span class="keyword">class</span> originalSelector:(SEL)origSel swizzledSelector:(SEL)swizSel &#123;</span><br><span class="line"></span><br><span class="line">    Method origMethod = class_getInstanceMethod(<span class="keyword">class</span>, origSel);</span><br><span class="line">    Method swizMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizSel);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, origSel, method_getImplementation(swizMethod), method_getTypeEncoding(swizMethod));</span><br><span class="line">    <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">        class_replaceMethod(<span class="keyword">class</span>, swizSel, method_getImplementation(origMethod), method_getTypeEncoding(origMethod));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        method_exchangeImplementations(origMethod, swizMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Method Swizzling 是一种黑魔法，我们在使用它时需要加倍小心。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/3efc3e94b14c" target="_blank" rel="noopener">iOS runtime实战应用：Method Swizzling</a></p>
<p><a href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="noopener">Objective-C Method Swizzling 的最佳实践</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Method Swizzling</tag>
        <tag>runtime</tag>
        <tag>方法交换</tag>
        <tag>黑魔法</tag>
      </tags>
  </entry>
  <entry>
    <title>用repository对hexo进行版本控制</title>
    <url>/2016/11/09/hexo-add-repo-more-PC/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果要在不同的电脑写作和更新博客，就要对博客进行版本控制，我在另一篇<a href="https://leroy0205.github.io/2016/11/07/hexo-more-PC/" target="_blank" rel="noopener">文章</a>中介绍了使用新的分支来进行版本控制，今天主要说说使用新的resository来对hexo进行版本控制。</p>
<a id="more"></a>
<h2 id="新建仓库repository"><a href="#新建仓库repository" class="headerlink" title="新建仓库repository"></a>新建仓库repository</h2><p>假如A电脑是你最开始新建博客的电脑，B电脑是新电脑</p>
<ol>
<li><p>在github新建仓库名为blog</p>
</li>
<li><p>上传A电脑本地Hexo博客的源文件夹至github的blog仓库，流程如下：</p>
</li>
</ol>
<ul>
<li><p>删除根目录和主题目录下的.git文件夹(.git默认是隐藏的)</p>
</li>
<li><p>在根目录下的.gitignore文件添加：</p>
</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">/.deploy_git</span></span><br><span class="line"></span><br><span class="line"><span class="string">/public</span></span><br></pre></td></tr></table></figure>
<ul>
<li>依次执行以下指令，同步源文件至github</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  git init</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git commit -m <span class="string">""</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git remote add origin git@github.com:leroyli/blog.git</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git push -u origin master</span></span><br><span class="line"></span><br><span class="line">//此时可能会出错failed to push some refs to git  出现错误的主要原因是github中的README.md文件不在本地代码目录中，可以通过如下命令进行代码合并</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git pull --rebase origin master</span></span><br><span class="line"></span><br><span class="line">此时再执行语句</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git push -u origin master</span></span><br></pre></td></tr></table></figure>
<p>即可完成代码上传到github</p>
<h2 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h2><ol>
<li><p>安装Git，并配置github账号下的B电脑的.ssh</p>
</li>
<li><p>安装Node.js</p>
</li>
<li><p>使用npm指令安装Hexo</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  npm install -g hexo-cli</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用Git bash随便选择一个文件夹,执行git clone</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$  git <span class="keyword">clone</span> <span class="title">git</span>@github.com:leroyli/blog.git</span><br></pre></td></tr></table></figure>
<p>至此，两个电脑的hexo环境一致，Hexo博客源文件一致</p>
<h2 id="已有环境"><a href="#已有环境" class="headerlink" title="已有环境"></a>已有环境</h2><ol>
<li>建议先检查更新git pull，将本地博客源文件更新至最新版本</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  git pull</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>然后可以新建或修改博客内容，进行预览等操作</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$  hexo new <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">$  hexo server</span><br><span class="line"></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新建博客后，先同步Hexo源文件，将修改后的源文件同步至github:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  git add .</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git commit -m <span class="string">"更新描述"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">  git push origin master</span></span><br></pre></td></tr></table></figure>
<ol start="4">
<li>然后再执行Hexo的生成文件和部署指令</li>
</ol>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$  hexo <span class="keyword">generate</span></span><br><span class="line"></span><br><span class="line">$  hexo deploy</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://sufaith.com/2016/02/27/Hexo%E8%BF%81%E7%A7%BB/" target="_blank" rel="noopener">Hexo在两台电脑间的操作流程</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>版本控制</tag>
        <tag>不同电脑</tag>
        <tag>博客同步</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中的+load和+initialize</title>
    <url>/2016/11/08/iOS-load-initialize/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C作为一门面向对象语言，有类和对象的概念。编译后，类相关的数据结构会保留在目标文件中，在运行时得到解析和使用。在应用程序运行起来的时候，类的信息会有加载和初始化过程。</p>
<p>就像Application有生命周期回调方法一样，在Objective-C的类被加载和初始化的时候，也可以收到方法回调，可以在适当的情况下做一些定制处理。而这正是load和initialize方法可以帮我们做到的。</p>
<a id="more"></a>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load;</span><br><span class="line">+ (<span class="keyword">void</span>)initialize;</span><br></pre></td></tr></table></figure>
<p>可以看到这两个方法都是以“+”开头的类方法，返回为空。通常情况下，我们在开发过程中可能不必关注这两个方法。如果有需要定制，我们可以在自定义的NSObject子类中给出这两个方法的实现，这样在类的加载和初始化过程中，自定义的方法可以得到调用。<br>从如上声明上来看，也许这两个方法和其它的类方法相比没什么特别。但是，这两个方法具有一定的“特殊性”，这也是这两个方法经常会被放在一起特殊提到的原因。</p>
<h2 id="initialize"><a href="#initialize" class="headerlink" title="initialize"></a>initialize</h2><p>Apple的<a href="https://developer.apple.com/reference/objectivec/nsobject?language=objc" target="_blank" rel="noopener">API Reference</a>中对initialize的描述：</p>
<blockquote>
<p>The runtime sends initialize to each class in a program just before the class, or any class that inherits from it, is sent its first message from within the program. Superclasses receive this message before their subclasses.</p>
</blockquote>
<blockquote>
<p>The runtime sends the initialize message to classes in a thread-safe manner. That is, initialize is run by the first thread to send a message to a class, and any other thread that tries to send a message to that class will block until initialize completes.</p>
</blockquote>
<blockquote>
<p>The superclass implementation may be called multiple times if subclasses do not implement initialize—the runtime will call the inherited implementation—or if subclasses explicitly call [super initialize]. If you want to protect yourself from being run multiple times, you can structure your implementation along these lines:</p>
</blockquote>
<blockquote>
<p>＋(void)initialize {<br>  if (self == [ClassName self]) {<br>    // … do the initialization …<br>  }<br>}</p>
</blockquote>
<blockquote>
<p>Because initialize is called in a blocking manner, it’s important to limit method implementations to the minimum amount of work necessary possible. Specifically, any code that takes locks that might be required by other classes in their initialize methods is liable to lead to deadlocks. Therefore, you should not rely on initialize for complex initialization, and should instead limit it to straightforward, class local initialization.</p>
</blockquote>
<p>+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。那这样设计有什么好处呢？好处是显而易见的，那就是节省系统资源，避免浪费。</p>
<ol>
<li><p>在首次使用该类之前由运行期系统（非人为）调用，且仅调用一次</p>
</li>
<li><p>惰性调用，只有当程序使用相关类时，才会调用</p>
</li>
<li><p>运行期系统会确保initialize方法是在线程安全的环境中执行，即，只有执行initialize的那个线程可以操作类或类实例。其他线程都要先阻塞，等待initialize执行完</p>
</li>
<li><p>如果类未实现initialize方法，而其超类实现了，那么会运行超类的实现代码，而且会运行两次（load 第5点）</p>
</li>
</ol>
<ul>
<li>initialize 遵循继承规则</li>
<li>初始化子类的的时候会先初始化父类，然后会调用父类的initialize方法，而子类没有覆写initialize方法，因此会再次调用父类的实现方法</li>
<li>鉴于此，initialize方法实现如下：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><p>官方文档说明：</p>
<blockquote>
<p>The load message is sent to classes and categories that are both dynamically loaded and statically linked, but only if the newly loaded class or category implements a method that can respond.</p>
</blockquote>
<blockquote>
<p>The order of initialization is as follows:</p>
</blockquote>
<blockquote>
<ol>
<li>All initializers in any framework you link to.</li>
</ol>
</blockquote>
<blockquote>
<ol start="2">
<li>All +load methods in your image.</li>
</ol>
</blockquote>
<blockquote>
<ol start="3">
<li>All C++ static initializers and C/C++ <strong>attribute</strong>(constructor) functions in your image.</li>
</ol>
</blockquote>
<blockquote>
<ol start="4">
<li>All initializers in frameworks that link to you.</li>
</ol>
</blockquote>
<blockquote>
<p>In addition:</p>
</blockquote>
<blockquote>
<p>A class’s +load method is called after all of its superclasses’ +load methods.</p>
</blockquote>
<blockquote>
<p>A category +load method is called after the class’s own +load method.</p>
</blockquote>
<blockquote>
<p>In a custom implementation of load you can therefore safely message other unrelated classes from the same image, but any load methods implemented by those classes may not have run yet.</p>
</blockquote>
<blockquote>
<p>Important</p>
</blockquote>
<blockquote>
<p>Custom implementations of the load method for Swift classes bridged to Objective-C are not called automatically.</p>
</blockquote>
<p>+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的，实现这个方法可以让我们在类加载的时候执行一些类相关的行为。子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>
<ol>
<li><p>对于加入运行期系统的类及分类，必定会调用此方法，且仅调用一次。</p>
</li>
<li><p>iOS会在应用程序启动的时候调用load方法，在main函数之前调用</p>
</li>
<li><p>执行子类的load方法前，会先执行所有超类的load方法，顺序为父类-&gt;子类-&gt;分类</p>
</li>
<li><p>在load方法中使用其他类是不安全的，因为会调用其他类的load方法，而如果关系复杂的话，就无法判断出各个类的载入顺序，类只有初始化完成后，类实例才能进行正常使用</p>
</li>
<li><p>load 方法不遵从继承规则，如果类本身没有实现load方法，那么系统就不会调用，不管父类有没有实现（跟initialize有明显区别）</p>
</li>
<li><p>尽可能的精简load方法，因为整个应用程序在执行load方法时会阻塞，即，程序会阻塞直到所有类的load方法执行完毕，才会继续</p>
</li>
<li><p>load 方法中最常用的就是方法交换method swizzling</p>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1. load和initialize方法都会在实例化对象之前调用，以main函数为分水岭，前者在main函数之前调用，后者在之后调用。这两个方法会被自动调用，不能手动调用它们。</strong></p>
<p><strong>2. load和initialize方法都不用显示的调用父类的方法而是自动调用，即使子类没有initialize方法也会调用父类的方法，而load方法则不会调用父类。</strong></p>
<p><strong>3. load方法通常用来进行Method Swizzle，initialize方法一般用于初始化全局变量或静态变量</strong></p>
<p><strong>4. load和initialize方法内部使用了锁，因此它们是线程安全的。实现时要尽可能保持简单，避免阻塞线程，不要再使用锁。</strong></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
        <tag>load</tag>
        <tag>initialize</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS内存管理</title>
    <url>/2016/11/08/iOS-ARC-MRC/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C中提供了两种内存管理机制：MRC（MannulReference Counting）和 ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。iOS 5之前普遍使用MRC来管理内存。iOS 5之后，苹果推出ARC。现在普遍时候ARC来管理内存。</p>
<a id="more"></a>
<h2 id="iOS内存分区"><a href="#iOS内存分区" class="headerlink" title="iOS内存分区"></a>iOS内存分区</h2><p>iOS的内存分区跟C语言类似：</p>
<ul>
<li><p><strong>栈区（stack）：</strong>存放的局部变量、先进后出、一旦出了作用域就会被销毁；函数跳转地址，现场保护等；程序猿不需要管理栈区变量的内存；栈区地址从高到低分配。</p>
</li>
<li><p><strong>堆区（heap）：</strong>堆区的内存分配使用的是alloc；需要程序猿管理内存；ARC的内存的管理，是编译器再编译的时候自动添加retain、release、autorelease；堆区的地址是从低到高分配。</p>
</li>
<li><p><strong>全局区/静态区（static）：</strong>包括两个部分：未初始化过 、初始化过；也就是说，（全局区/静态区）在内存中是放在一起的，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域；eg：int a;未初始化的。int a = 10;已初始化的。</p>
</li>
<li><p><strong>常量区：</strong>常量字符串就是放在这里。</p>
</li>
<li><p><strong>代码区：</strong>存放App二进制代码。</p>
</li>
</ul>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>在谈ARC和MRC之前我们先来谈谈引用计数</p>
<p>引用计数（Reference Count）是一个简单而有效的管理对象生命周期的方式。当我们创建一个新对象的时候，它的引用计数为 1，当有一个新的指针指向这个对象时，我们将其引用计数加 1，当某个指针不再指向这个对象是，我们将其引用计数减 1，当对象的引用计数变为 0 时，说明这个对象不再被任何指针指向了，这个时候我们就可以将对象销毁，回收内存。由于引用计数简单有效，除了 Objective-C 和 Swift 语言外，微软的 COM（Component Object Model ）、C++11（C++11 提供了基于引用计数的智能指针 share_prt）等语言也提供了基于引用计数的内存管理方式。</p>
<h2 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h2><p>MRC即我们通过人为的方式来控制引用计数器的增减，影响对象RetainCount值得方法有以下几种:</p>
<ol>
<li>new、alloc、copy、mutableCopy，这几种方法用来创建一个新的对象并且获得对象的所有权，此时RC的值默认为RetainCount=1；</li>
<li>retain,对象调用retain方法，该对象的RetainCount+1;</li>
<li>release，对象调用 release方法，该对象的RetainCount-1;</li>
<li>dealloc，dealloc方法并不会影响RetainCount的值，但是当RetainCount的值为0时，系统会调用dealloc方法来销毁对象。</li>
</ol>
<p>在MRC模式下，如果一个对象被释放，它的RetainCount并不是立即变为0的<br>例如：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSObject</span> *object = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    [object release];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reference Count = %u"</span>, [object retainCount]);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果：<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">Reference Count = <span class="number">1</span></span><br><span class="line">Reference Count = <span class="number">1</span></span><br></pre></td></tr></table></figure></p>
<p>我们注意到，最后一次输出，引用计数并没有变成 0。这是为什么呢？因为该对象的内存已经被回收，而我们向一个已经被回收的对象发了一个 retainCount 消息，所以它的输出结果应该是不确定的，如果该对象所占的内存被复用了，那么就有可能造成程序异常崩溃。<br>那为什么在这个对象被回收之后，这个不确定的值是 1 而不是 0 呢？这是因为当最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。</p>
<p>MRC下内存管理有是个法则</p>
<ul>
<li>自己生成的对象，自己持有。</li>
<li>非自己生成的对象，自己也能持有。</li>
<li>不在需要自己持有对象的时候，释放。</li>
<li>非自己持有的对象无需释放。</li>
</ul>
<h2 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h2><p>ARC 是苹果引入的一种自动内存管理机制，会根据引用计数自动监视对象的生存周期，实现方式是在编译时期自动在已有代码中插入合适的内存管理代码以及在 Runtime 做一些优化。</p>
<p>ARC模式下，创建的新对象通常由以下几种关键字来限定</p>
<ol>
<li><strong>strong(默认值)，由</strong>strong修饰的为强指针，对象只要有强指针指向就不会被销毁；每当一个强指针指向一个对象，该对象的的RC+1；</li>
<li><strong>weak,由</strong>weak修饰的为弱指针，弱指针所指向的对象并不会改变RC值，弱指针只表示是对对象的引用；当弱指针所指向的对象销毁时，该弱指针的值变为nil；</li>
<li><strong>unsafe_unretained,</strong>unsafe_unretained修饰的对象指针所指向的对象也不会改变RC值，也只表示是对对象的引用；当所指向的对象销毁时，该指针的值不会变为nil，仍是保留原有的地址</li>
</ol>
<p>在ARC模式下，MRC中的retain、release等方法变的不可用，因为ARC是不需要我们手动管理内存的，一切由编译器完成。</p>
<p>ARC虽然是自动管理引用计数，但是如果使用不当也会造成内存泄漏。<br>ARC下有以下几个内存泄漏的点：</p>
<ul>
<li><strong>Delegate</strong></li>
<li><strong>Block</strong></li>
<li><strong>NSTimer</strong></li>
<li><strong>CoreFundation/CoreGraphics</strong></li>
<li><strong>performSelector</strong></li>
</ul>
<p>Xcode 的 Instruments 工具集可以很方便的检测循环引用</p>
<h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><p><strong>strong ：</strong>强引用，ARC中使用，与MRC中retain类似，使用之后，计数器+1。<br><strong>weak ：</strong>弱引用 ，ARC中使用，如果只想的对象被释放了，其指向nil，可以有效的避免野指针，其引用计数为1。<br><strong>readwrite : </strong>可读可写特性，需要生成getter方法和setter方法时使用。<br><strong>readonly : </strong>只读特性，只会生成getter方法 不会生成setter方法，不希望属性在类外改变。<br><strong>assign ：</strong>赋值特性，不涉及引用计数，弱引用，setter方法将传入参数赋值给实例变量，仅设置变量时使用。<br><strong>retain ：</strong>表示持有特性，setter方法将传入参数先保留，再赋值，传入参数的retaincount会+1。<br><strong>copy ：</strong>表示拷贝特性，setter方法将传入对象复制一份，需要完全一份新的变量时。<br><strong>nonatomic ：</strong>非原子操作，不加同步，多线程访问可提高性能，但是线程不安全的。决定编译器生成的setter getter是否是原子操作。<br><strong>atomic ：</strong>原子操作，同步的，表示多线程安全，与nonatomic相反。</p>
<p>ARC下默认关键字</p>
<ul>
<li>对应基本数据类型默认关键字是<br><strong>atomic,readwrite,assign</strong></li>
<li>对于普通的 Objective-C 对象<br><strong>atomic,readwrite,strong</strong></li>
</ul>
<p>既然说到了@property就说说@synthesize和@dynamic</p>
<p>@property有两个对应的词，一个是 <strong>@synthesize</strong>，一个是 <strong>@dynamic</strong>。如果 @synthesize和 @dynamic都没写，那么默认的就是@syntheszie var = _var;</p>
<p><strong>@synthesize</strong> 的语义是如果你没有手动实现 setter 方法和 getter 方法，那么编译器会自动为你加上这两个方法。</p>
<p><strong>@dynamic</strong> 告诉编译器：属性的 setter 与 getter 方法由用户自己实现，不自动生成。（当然对于 readonly 的属性只需提供 getter 即可）。假如一个属性被声明为 @dynamic var，然后你没有提供 @setter方法和 @getter 方法，编译的时候没问题，但是当程序运行到 instance.var = someVar，由于缺 setter 方法会导致程序崩溃；或者当运行到 someVar = var 时，由于缺 getter 方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。</p>
<h2 id="ARC和MRC混编"><a href="#ARC和MRC混编" class="headerlink" title="ARC和MRC混编"></a>ARC和MRC混编</h2><ol>
<li><p>在targets的build phases选项下Compile Sources下选择，不使用arc编译的文件，双击它，输入 -fno-objc-arc 即可（这个类就可以使用MRC模式）</p>
</li>
<li><p>MRC工程中也可以使用ARC的类。方法如下：<br>在targets的build phases选项下Compile Sources下选择要使用arc编译的文件，双击它，输入 -fobjc-arc 即可</p>
</li>
</ol>
<h2 id="Autorelease-Pool"><a href="#Autorelease-Pool" class="headerlink" title="Autorelease Pool"></a>Autorelease Pool</h2><p>Autorelase Pool 提供了一种可以允许你向一个对象延迟发送release消息的机制。当你想放弃一个对象的所有权，同时又不希望这个对象立即被释放掉（例如在一个方法中返回一个对象时），Autorelease Pool 的作用就显现出来了。<br>谓的延迟发送release消息指的是，当我们把一个对象标记为autorelease时.这个对象的 retainCount 会+1，但是并不会发生 release。当这段语句所处的 autoreleasepool 进行 drain 操作时，所有标记了 autorelease 的对象的 retainCount 会被 -1。即 release 消息的发送被延迟到 pool 释放的时候了。<br>在ARC 环境下，苹果引入了 @autoreleasepool 语法，不再需要手动调用 autorelease 和 drain 等方法</p>
<p>autoreleasepool 以一个队列数组的形式实现,主要通过下列三个函数完成.</p>
<ul>
<li>objc_autoreleasepoolPush</li>
<li>objc_autoreleasepoolPop</li>
<li>objc_autorelease<br>看函数名就可以知道，对 autorelease 分别执行 push，和 pop 操作。销毁对象时执行release操作。</li>
</ul>
<h4 id="Autorelease-Pool-的用处"><a href="#Autorelease-Pool-的用处" class="headerlink" title="Autorelease Pool 的用处"></a>Autorelease Pool 的用处</h4><p>在 ARC 下，我们并不需要手动调用 autorelease 有关的方法，甚至可以完全不知道 autorelease 的存在，就可以正确管理好内存。因为 Cocoa Touch 的 Runloop 中，每个 runloop circle 中系统都自动加入了 Autorelease Pool 的创建和释放。</p>
<p>当我们需要创建和销毁大量的对象时，使用手动创建的 autoreleasepool 可以有效的避免内存峰值的出现。因为如果不手动创建的话，外层系统创建的 pool 会在整个 runloop circle 结束之后才进行 drain，手动创建的话，会在 block 结束之后就进行 drain 操作。详情请参考苹果官方文档。一个普遍被使用的例子如下</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">NSString</span>* string = <span class="string">@"ab c"</span>;</span><br><span class="line">        <span class="built_in">NSArray</span>* array = [string componentsSeparatedByString:string];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不使用 autoreleasepool ，需要在循环结束之后释放 100000000 个字符串，如果 使用的话，则会在每次循环结束的时候都进行 release 操作。</p>
<h4 id="main-m-中-Autorelease-Pool-的解释"><a href="#main-m-中-Autorelease-Pool-的解释" class="headerlink" title="main.m 中 Autorelease Pool 的解释"></a>main.m 中 Autorelease Pool 的解释</h4><p>大家都知道在 iOS 程序的 main.m 文件中有类似这样的语句：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据苹果官方文档， UIApplicationMain 函数是整个 app 的入口，用来创建 application 对象（单例）和 application delegate。尽管这个函数有返回值，但是实际上却永远不会返回，当按下 Home 键时，app 只是被切换到了后台状态。</p>
<p>同时参考苹果关于 Lifecycle 的官方文档，UIApplication 自己会创建一个 main run loop，我们大致可以得到下面的结论：</p>
<ol>
<li>main.m 中的 UIApplicationMain 永远不会返回，只有在系统 kill 掉整个 app 时，系统会把应用占用的内存全部释放出来。</li>
<li>因为(1)， UIApplicationMain 永远不会返回，这里的 autorelease pool 也就永远不会进入到释放那个阶段</li>
<li>在 (2) 的基础上，假设有些变量真的进入了 main.m 里面这个 pool（没有被更内层的 pool 捕获），那么这些变量实际上就是被泄露的。这个 autorelease pool 等于是把这种泄露情况给隐藏起来了。</li>
<li>UIApplication 自己会创建 main run loop，在 Cocoa 的 runloop 中实际上也是自动包含 autorelease pool 的，因此 main.m 当中的 pool 可以认为是没有必要的</li>
</ol>
<p>基于 AppKit 框架的 Mac OS 开发中， main.m 当中就是不存在 autorelease pool 的，也进一步验证了我们得到的结论。不过因为我们看不到更底层的代码，加上苹果的文档中不建议修改 main.m ，所以我们也没有理由就直接把它删掉（亲测，删掉之后不影响 App 运行，用 Instruments 也看不到泄露）。</p>
<p>以上就是对内存管理的一些总结。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.devtang.com/2016/07/30/ios-memory-management/" target="_blank" rel="noopener">理解 iOS 的内存管理</a><br><a href="https://hit-alibaba.github.io/interview/iOS/ObjC-Basic/MM.html" target="_blank" rel="noopener">Objective-C内存管理</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ARC</tag>
        <tag>MRC</tag>
        <tag>内存管理</tag>
        <tag>引用计数</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法格式指南</title>
    <url>/2016/11/08/markdown-writing/</url>
    <content><![CDATA[<h2 id="Markdown是什么"><a href="#Markdown是什么" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h2><p>Markdown是一种轻量级标记语言，它以纯文本形式(易读、易写、易更改)编写文档，并最终以HTML格式发布。<br>Markdown也可以理解为将以MARKDOWN语言编写的语言转换成HTML内容的工具，最初是一个perl脚本Markdown.pl。<br>简单来说，Markdown是一个兼顾可读性与易用性的轻量级标记体系。Markdown并不追求大而全，它只关心HTML里最常用的几个标记，对于一些不常用的标记它允许直接将HTML标记插入文本。<br><a id="more"></a></p>
<h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>标题有两种形式<br><strong>使用=和-标记一级和二级标题</strong><br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=========</span><br><span class="line">二级标题</span><br><span class="line">---------</span><br></pre></td></tr></table></figure></p>
<p>效果：</p>
<blockquote>
<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p><strong>使用#，可表示1-6级标题</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1></blockquote>
<h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>使用*、+、或-标记无序列表,符号后记得加空格<br><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">-<span class="ruby"> 文本<span class="number">1</span></span></span><br><span class="line"><span class="ruby">- 文本<span class="number">2</span></span></span><br><span class="line"><span class="ruby">- 文本<span class="number">3</span></span></span><br></pre></td></tr></table></figure></p>
<p>效果：</p>
<blockquote>
<ul>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ul>
</blockquote>
<p>如果你希望有序列表，<br>也可以在文字前面加上 1. 2. 3. 就可以了</p>
<figure class="highlight lsl"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 文本<span class="number">1</span></span><br><span class="line"><span class="number">2.</span> 文本<span class="number">2</span></span><br><span class="line"><span class="number">3.</span> 文本<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<ol>
<li>文本1</li>
<li>文本2</li>
<li>文本3</li>
</ol>
</blockquote>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>在段落的每行或者只在第一行使用符号&gt;,还可使用多个嵌套引用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> 区块引用</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt; 嵌套引用</span></span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>区块引用</p>
<blockquote>
<p>嵌套引用</p>
</blockquote>
</blockquote>
<h2 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h2><p>在强调内容两侧分别加上*<br><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line"><span class="strong">*斜体*</span></span><br><span class="line">*<span class="strong">*粗体*</span><span class="strong">*</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><em>斜体</em><br><strong>粗体</strong></p>
</blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>需要引用代码时，如果引用的语句只有一段，不分行，可以用 <code>将语句包起来。
如果引用的语句为多行，可以将``</code>置于这段代码的首行和末行。</p>
<h2 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h2><p>在 Markdown 中，插入链接不需要其他按钮，你只需要使用<code>[显示文本](链接地址)</code>这样的语法即可</p>
<p>在 Markdown 中，插入图片不需要其他按钮，你只需要使用<code>![](图片链接地址)</code>这样的语法即可</p>
<p>以上就是一些常用的Markdown语法，应付写作应该足够了，希望能够帮助到大家。如果想了解更多，请参考<a href="http://wowubuntu.com/markdown/" target="_blank" rel="noopener">Markdown 语法说明</a></p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>格式</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS runtime详解</title>
    <url>/2016/11/07/iOS-runtime/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。了解 Runtime ，要先了解它的OC中类和对象的结构 然后了解消息传递 （Messaging）。</p>
<a id="more"></a>
<h2 id="OC中类和对象的结构"><a href="#OC中类和对象的结构" class="headerlink" title="OC中类和对象的结构"></a>OC中类和对象的结构</h2><p>Objective-C类是由Class类型来表示的，它实际上是一个指<br>向objc_class结构体的指针。<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> object_class *Class</span><br></pre></td></tr></table></figure></p>
<p>查看objc/runtime.h中objc_class结构体的定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> object_class&#123;</span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">     Class super_class                        OBJC2_UNAVAILABLE;  <span class="comment">// 父类</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name                         OBJC2_UNAVAILABLE;  <span class="comment">// 类名</span></span><br><span class="line">     <span class="keyword">long</span> version                             OBJC2_UNAVAILABLE;  <span class="comment">// 类的版本信息，默认为0</span></span><br><span class="line">     <span class="keyword">long</span> info                                OBJC2_UNAVAILABLE;  <span class="comment">// 类信息，供运行期使用的一些位标识</span></span><br><span class="line">     <span class="keyword">long</span> instance_size                       OBJC2_UNAVAILABLE;  <span class="comment">// 该类的实例变量大小</span></span><br><span class="line">     <span class="keyword">struct</span> objc_ivar_list *ivars             OBJC2_UNAVAILABLE;  <span class="comment">// 该类的成员变量链表</span></span><br><span class="line">     <span class="keyword">struct</span> objc_method_list *methodLists     OBJC2_UNAVAILABLE;  <span class="comment">// 方法定义的链表</span></span><br><span class="line">     <span class="keyword">struct</span> objc_cache *cache                 OBJC2_UNAVAILABLE;  <span class="comment">// 方法缓存</span></span><br><span class="line">     <span class="keyword">struct</span> objc_protocol_list *protocols     OBJC2_UNAVAILABLE;  <span class="comment">// 协议链表</span></span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p><strong>objc_object</strong></p>
<p>objc_object是表示一个类的实例的结构体<br>它的定义如下(objc/objc.h)：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_object&#123;</span><br><span class="line">     Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br></pre></td></tr></table></figure>
<p>这个结构体只有一个指针，即指向其类的isa指针。这<br>样，当我们向一个Objective-C对象发送消息时，运行时库会根据<br>实例对象的isa指针找到这个实例对象所属的类。Runtime库会在类的方法列表及父类的方法列表中去寻找与消息对应的selector指向的方法，找到后即运行这个方法。</p>
<p><strong>元类(Meta Class)</strong></p>
<p>objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类。</p>
<h2 id="方法与消息"><a href="#方法与消息" class="headerlink" title="方法与消息"></a>方法与消息</h2><p><strong>SEL</strong></p>
<p>SEL又叫选择器，是表示一个方法的selector的指针，其定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_selector *SEL；</span><br></pre></td></tr></table></figure>
<p>方法的selector用于表示运行时方法的名字。Objective-C在编译时，会依据每一个方法的名字、参数序列，生成一个唯一的整型标识(Int类型的地址)，这个标识就是SEL。<br>两个类之间，只要方法名相同，那么方法的SEL就是一样的，每一个方法都对应着一个SEL。所以在Objective-C同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行<br>当然，不同的类可以拥有相同的selector，这个没有问题。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的IMP。<br>工程中的所有的SEL组成一个Set集合，如果我们想到这个方法集合中查找某个方法时，只需要去找到这个方法对应的SEL就行了，SEL实际上就是根据方法名hash化了的一个字符串，而对于字符串的比较仅仅需要比较他们的地址就可以了，可以说速度上无语伦比！<br>本质上，SEL只是一个指向方法的指针（准确的说，只是一个根据方法名hash化了的KEY值，能唯一代表一个方法），它的存在只是为了加快方法的查询速度。<br>通过下面三种方法可以获取SEL:</p>
<ul>
<li>sel_registerName函数</li>
<li>Objective-C编译器提供的@selector()</li>
<li>NSSelectorFromString()方法</li>
</ul>
<p><strong>IMP</strong></p>
<p>IMP实际上是一个函数指针，指向方法实现的地址。<br>其定义如下:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">id</span> (*IMP)(<span class="keyword">id</span>, SEL,...)</span><br></pre></td></tr></table></figure>
<p>第一个参数：是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)<br>第二个参数：是方法选择器(selector)<br>接下来的参数：方法的参数列表。<br>前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。</p>
<p><strong>Method</strong></p>
<p>Method用于表示类定义中的方法，则定义如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_method *Method</span><br><span class="line"><span class="keyword">struct</span> objc_method&#123;</span><br><span class="line">    SEL method_name      OBJC2_UNAVAILABLE; <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">char</span> *method_types   OBJC2_UNAVAILABLE;</span><br><span class="line">    IMP method_imp       OBJC2_UNAVAILABLE; <span class="comment">// 方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到该结构体中包含一个SEL和IMP，实际上相当于在SEL和IMP之间作了一个映射。有了SEL，我们便可以找到对应的IMP，从而调用方法的实现代码。</p>
<p><strong>方法调用流程</strong></p>
<img src="/2016/11/07/iOS-runtime/runtime1.png">
<p>在Objective-C中，消息直到运行时才绑定到方法实现上。编译器会将消息表达式[receiver message]转化为一个消息函数的调用，即objc_msgSend。这个函数将消息接收者和方法名作为其基础参数，如以下所示</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend(receiver, selector)</span><br></pre></td></tr></table></figure>
<p>如果消息中还有其它参数，则该方法的形式如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">objc_msgSend(receiver, selector, arg1, arg2,...)</span><br></pre></td></tr></table></figure>
<p>这个函数完成了动态绑定的所有事情.</p>
<p>基本流程就是：<br>objc_msgSend通过对象的isa指针获取到类的结构体，然后在方法的缓存列表里面查找方法的selector。如果缓存里没有再去方法列表里去找。<br>如果没有找到selector，objc_msgSend结构体中的指向父类的指针找到其父类，并在父类的缓存里面查找方法的selector。<br>依此，会一直沿着类的继承体系到达NSObject类。一旦定位到selector，函数会就获取到了实现的入口点，并传入相应的参数来执行方法的具体实现,并将该方法添加进入缓存中如果最后没有定位到selector，则会走消息转发流程。</p>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>当一个对象能接收一个消息时，就会走正常的方法调用流程。但如果一个对象无法接收指定消息时，也就是没有找到方法的实现时，通常情况下，程序会在运行时挂掉并抛出 unrecognized selector sent to … 的异常。但在异常抛出前，Objective-C 的运行时会给你三次拯救程序的机会：</p>
<ul>
<li>Method resolution</li>
<li>Fast forwarding</li>
<li>Normal forwarding</li>
</ul>
<p>以objc_msgSend(obj, foo)为例来分析下三种方式</p>
<h4 id="Method-resolution"><a href="#Method-resolution" class="headerlink" title="Method resolution"></a>Method resolution</h4><p>首先，Objective-C 运行时会调用 +resolveInstanceMethod: 或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数并返回 YES， 那运行时系统就会重新启动一次消息发送的过程。你可以这么实现：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMethod(<span class="keyword">id</span> obj, SEL _cmd)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Doing foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)aSEL</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSEL == <span class="keyword">@selector</span>(foo:))&#123;</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], aSEL, (IMP)fooMethod, <span class="string">"v@:"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 resolve 方法返回 NO ，运行时就会移到下一步：消息转发（Message Forwarding）。</p>
<h4 id="Fast-forwarding"><a href="#Fast-forwarding" class="headerlink" title="Fast forwarding"></a>Fast forwarding</h4><p>如果目标对象实现了 -forwardingTargetForSelector: ，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(foo:))&#123;</span><br><span class="line">        <span class="keyword">return</span> alternateObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要这个方法返回的不是 nil 和 self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续 Normal Fowarding 。</p>
<p>这里叫 Fast ，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个 NSInvocation 对象，所以相对更快点。</p>
<h4 id="Normal-forwarding"><a href="#Normal-forwarding" class="headerlink" title="Normal forwarding"></a>Normal forwarding</h4><p>这一步是 Runtime 最后一次给你挽救的机会。首先它会发送 -methodSignatureForSelector: 消息获得函数的参数和返回值类型。如果 -methodSignatureForSelector: 返回 nil ，Runtime 则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime 就会创建一个 NSInvocation 对象并发送 -forwardInvocation: 消息给目标对象。</p>
<p>NSInvocation 实际上就是对一个消息的描述，包括selector 以及参数等信息。所以你可以在 -forwardInvocation: 里修改传进来的 NSInvocation 对象，然后发送 -invokeWithTarget: 消息给它，传进去一个新的目标：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation</span><br><span class="line">&#123;</span><br><span class="line">    SEL sel = invocation.selector;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>([alternateObject respondsToSelector:sel]) &#123;</span><br><span class="line">        [invocation invokeWithTarget:alternateObject];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> doesNotRecognizeSelector:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.jianshu.com/p/adf0d566c887" target="_blank" rel="noopener">iOS运行时(Runtime)详解+Demo</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>runtime</tag>
        <tag>运行时</tag>
      </tags>
  </entry>
  <entry>
    <title>关于iOS多线程</title>
    <url>/2016/11/07/iOS-more-Thread/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>计算机操作系统都有的基本概念，以下概念简单方式来描述。<br><strong>进程：</strong>一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。<br><strong>线程：</strong>程序执行流的最小单元，线程是进程中的一个实体。<br><strong>同步：</strong>只能在当前线程按先后顺序依次执行，不开启新线程。<br><strong>异步：</strong>可以在当前线程开启多个新线程执行，可不按顺序执行。<br><strong>队列：</strong>装载线程任务的队形结构。<br><strong>并发：</strong>线程执行可以同时一起进行执行。<br><strong>串行：</strong>线程执行只能依次逐一先后有序的执行。</p>
<a id="more"></a>
<p><strong>进程和线程的比较</strong></p>
<ol>
<li>线程是CPU调用(执行任务)的最小单位。</li>
<li>进程是CPU分配资源的最小单位。</li>
<li>一个进程中至少要有一个线程。</li>
<li>同一个进程内的线程共享进程的资源。</li>
</ol>
<p>一个进程可有多个线程，一个进程可有多个队列，队列可分并发队列和串行队列。</p>
<p>另外说到多线程就说说并发和并行，在知乎上看到一个人的回答感觉很形象：<br>并发的关键是你有处理多个任务的能力，不一定要同时。<br>并行的关键是你有同时处理多个任务的能力。<br>它们的关键点就是：是否是同时</p>
<p><strong>多线程原理</strong></p>
<p>同一时间，CPU只能处理1条线程，只有1条线程在工作（执行），多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。<br>那么如果线程非常非常多，会发生什么情况？<br>CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源，同时每条线程被调度执行的频次也会会降低（线程的执行效率降低）。<br>因此我们一般只开3-5条线程。</p>
<p><strong>多线程优缺点</strong></p>
<p>多线程的优点<br>能适当提高程序的执行效率<br>能适当提高资源利用率（CPU、内存利用率）<br>多线程的缺点<br>创建线程是有开销的，iOS下主要成本包括：内核数据结构（大约1KB）、栈空间（子线程512KB、主线程1MB，也可以使用-setStackSize:设置，但必须是4K的倍数，而且最小是16K），创建线程大约需要90毫秒的创建时间<br>如果开启大量的线程，会降低程序的性能，线程越多，CPU在调度线程上的开销就越大。<br>程序设计更加复杂：比如线程之间的通信、多线程的数据共享等问题。</p>
<p><strong>多线程的应用</strong></p>
<p>主线程的主要作用<br>显示/刷新UI界面<br>处理UI事件（比如点击事件、滚动事件、拖拽事件等）<br>主线程的使用注意<br>别将比较耗时的操作放到主线程中<br>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验<br>将耗时操作放在子线程中执行，提高程序的执行效率</p>
<h2 id="iOS多线程几种实现方式"><a href="#iOS多线程几种实现方式" class="headerlink" title="iOS多线程几种实现方式"></a>iOS多线程几种实现方式</h2><p>iOS 中实现多线程的方法有4种</p>
<ul>
<li><strong>Pthreads</strong></li>
<li><strong>NSThread</strong></li>
<li><strong>GCD</strong></li>
<li><strong>NSOperation</strong><br>其中pthread，GCD是基于C的。NSThread，NSOperationQueue基于OC的。</li>
</ul>
<h2 id="iOS多线程的对比"><a href="#iOS多线程的对比" class="headerlink" title="iOS多线程的对比"></a>iOS多线程的对比</h2><p>由于开发中都是用NSThread，GCD，NSOperation。所以此处只比较这三种</p>
<h4 id="NSThread"><a href="#NSThread" class="headerlink" title="NSThread"></a>NSThread</h4><p>每个NSThread对象对应一个线程，真正最原始的线程。<br><strong>优点：</strong>NSThread 轻量级最低，相对简单。<br><strong>缺点：</strong>手动管理所有的线程活动，如生命周期、线程同步、睡眠等。</p>
<h4 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h4><p>自带线程管理的抽象类。<br><strong>优点：</strong>自带线程周期管理，操作上可更注重自己逻辑。<br><strong>缺点：</strong>面向对象的抽象类，只能实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。</p>
<h4 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h4><p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。<br><strong>优点：</strong>最高效，避开并发陷阱。<br><strong>缺点：</strong>基于C实现。</p>
<h2 id="多线程的实现"><a href="#多线程的实现" class="headerlink" title="多线程的实现"></a>多线程的实现</h2><p>由于pthread几乎不使用，这里不做讨论</p>
<h4 id="一、NSThread的实现"><a href="#一、NSThread的实现" class="headerlink" title="一、NSThread的实现"></a>一、NSThread的实现</h4><h6 id="1-创建线程"><a href="#1-创建线程" class="headerlink" title="1.创建线程"></a>1.创建线程</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一：创建线程，需要自己开启线程</span></span><br><span class="line"><span class="built_in">NSThread</span> *thread = [[<span class="built_in">NSThread</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 开启线程</span></span><br><span class="line">[thread start];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：创建线程后自动启动线程</span></span><br><span class="line">[<span class="built_in">NSThread</span> detachNewThreadSelector:<span class="keyword">@selector</span>(run) toTarget:<span class="keyword">self</span> withObject:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法三：隐式创建并启动线程</span></span><br><span class="line">[<span class="keyword">self</span> performSelectorInBackground:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>后面两种方法都不用我们开启线程，相对方便快捷，但是没有办法拿到子线程对象，没有办法对子线程进行更详细的设置，例如线程名字和优先级等。</p>
<h6 id="2-NSThread的属性"><a href="#2-NSThread的属性" class="headerlink" title="2.NSThread的属性"></a>2.NSThread的属性</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前线程</span></span><br><span class="line"> + (<span class="built_in">NSThread</span> *)currentThread;</span><br><span class="line"> <span class="comment">// 创建启动线程</span></span><br><span class="line"> + (<span class="keyword">void</span>)detachNewThreadSelector:(SEL)selector toTarget:(<span class="keyword">id</span>)target withObject:(<span class="keyword">id</span>)argument;</span><br><span class="line"> <span class="comment">// 判断是否是多线程</span></span><br><span class="line"> + (<span class="built_in">BOOL</span>)isMultiThreaded;</span><br><span class="line"> <span class="comment">// 线程休眠 NSDate 休眠到什么时候</span></span><br><span class="line"> + (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line"> <span class="comment">// 线程休眠时间</span></span><br><span class="line"> + (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"> <span class="comment">// 结束/退出当前线程</span></span><br><span class="line"> + (<span class="keyword">void</span>)exit;</span><br><span class="line"> <span class="comment">// 获取当前线程优先级</span></span><br><span class="line"> + (<span class="keyword">double</span>)threadPriority;</span><br><span class="line"> <span class="comment">// 设置线程优先级 默认为0.5 取值范围为0.0 - 1.0</span></span><br><span class="line"> <span class="comment">// 1.0优先级最高</span></span><br><span class="line"> <span class="comment">// 设置优先级</span></span><br><span class="line"> + (<span class="built_in">BOOL</span>)setThreadPriority:(<span class="keyword">double</span>)p;</span><br><span class="line"> <span class="comment">// 获取指定线程的优先级</span></span><br><span class="line"> - (<span class="keyword">double</span>)threadPriority <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"> - (<span class="keyword">void</span>)setThreadPriority:(<span class="keyword">double</span>)p <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置线程的名字</span></span><br><span class="line"> - (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)n <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> - (<span class="built_in">NSString</span> *)name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 判断指定的线程是否是 主线程</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isMainThread <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 判断当前线程是否是主线程</span></span><br><span class="line"> + (<span class="built_in">BOOL</span>)isMainThread <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0); <span class="comment">// reports whether current thread is main</span></span><br><span class="line"> <span class="comment">// 获取主线程</span></span><br><span class="line"> + (<span class="built_in">NSThread</span> *)mainThread <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"> - (<span class="keyword">id</span>)init <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);    <span class="comment">// designated initializer</span></span><br><span class="line"> <span class="comment">// 创建线程</span></span><br><span class="line"> - (<span class="keyword">id</span>)initWithTarget:(<span class="keyword">id</span>)target selector:(SEL)selector object:(<span class="keyword">id</span>)argument <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 指定线程是否在执行</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isExecuting <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 线程是否完成</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isFinished <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 线程是否被取消 (是否给当前线程发过取消信号)</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isCancelled <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 发送线程取消信号的 最终线程是否结束 由 线程本身决定</span></span><br><span class="line"> - (<span class="keyword">void</span>)cancel <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"> <span class="comment">// 启动线程</span></span><br><span class="line"> - (<span class="keyword">void</span>)start <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 线程主函数  在线程中执行的函数 都要在-main函数中调用，自定义线程中重写-main方法</span></span><br><span class="line"> - (<span class="keyword">void</span>)main <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_5, <span class="number">2</span>_0);    <span class="comment">// thread body metho</span></span><br></pre></td></tr></table></figure>
<h6 id="3-NSThread线程的状态"><a href="#3-NSThread线程的状态" class="headerlink" title="3.NSThread线程的状态"></a>3.NSThread线程的状态</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">启动线程</span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line"><span class="comment">// 进入就绪状态 -&gt; 运行状态。当线程任务执行完毕，自动进入死亡状态</span></span><br><span class="line"></span><br><span class="line">阻塞（暂停）线程</span><br><span class="line">+ (<span class="keyword">void</span>)sleepUntilDate:(<span class="built_in">NSDate</span> *)date;</span><br><span class="line">+ (<span class="keyword">void</span>)sleepForTimeInterval:(<span class="built_in">NSTimeInterval</span>)ti;</span><br><span class="line"><span class="comment">// 进入阻塞状态</span></span><br><span class="line"></span><br><span class="line">强制停止线程</span><br><span class="line">+ (<span class="keyword">void</span>)exit;</span><br><span class="line"><span class="comment">// 进入死亡状态</span></span><br></pre></td></tr></table></figure>
<h6 id="4-NSThread多线程安全隐患"><a href="#4-NSThread多线程安全隐患" class="headerlink" title="4.NSThread多线程安全隐患"></a>4.NSThread多线程安全隐患</h6><p>多线程安全隐患的原因：1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件。<br>那么当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。<br>针对NSThread多线程安全隐患。我们可以使用互斥锁<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@synchronized</span>(锁对象) &#123;</span><br><span class="line"><span class="comment">// 需要锁定的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>互斥锁的使用前提：多条线程抢夺同一块资源时<br>注意：锁定1份代码只用1把锁，用多把锁是无效的<br>互斥锁的优缺点<br>优点：能有效防止因多线程抢夺资源造成的数据安全问题<br>缺点：需要消耗大量的CPU资源</p>
<h6 id="5-NSThread线程之间的通信"><a href="#5-NSThread线程之间的通信" class="headerlink" title="5.NSThread线程之间的通信"></a>5.NSThread线程之间的通信</h6><p>什么叫做线程间通信<br>在1个进程中，线程往往不是孤立存在的，多个线程之间需要经常进行通信，例如我们在子线程完成下载图片后，回到主线程刷新UI显示图片<br>线程间通信的体现<br>1个线程传递数据给另1个线程<br>在1个线程中执行完特定任务后，转到另1个线程继续执行任务<br>线程间通信常用的方法<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回主线程</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelectorOnMainThread:(SEL)aSelector withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br><span class="line"><span class="comment">// 返回指定线程</span></span><br><span class="line">- (<span class="keyword">void</span>)performSelector:(SEL)aSelector onThread:(<span class="built_in">NSThread</span> *)thr withObject:(<span class="keyword">id</span>)arg waitUntilDone:(<span class="built_in">BOOL</span>)wait;</span><br></pre></td></tr></table></figure></p>
<h4 id="二、NSOperation的实现"><a href="#二、NSOperation的实现" class="headerlink" title="二、NSOperation的实现"></a>二、NSOperation的实现</h4><p>NSOperation 是苹果公司对 GCD 的封装，完全面向对象，并比GCD多了一些更简单实用的功能，所以使用起来更加方便易于理解。NSOperation 和NSOperationQueue 分别对应 GCD 的 任务 和 队列。<br>NSOperation和NSOperationQueue实现多线程的具体步骤</p>
<ul>
<li>将需要执行的操作封装到一个NSOperation对象中</li>
<li>将NSOperation对象添加到NSOperationQueue中<br>系统会自动将NSOperationQueue中的NSOperation取出来，并将取出的NSOperation封装的操作放到一条新线程中执行</li>
</ul>
<h6 id="1-NSOperation的创建"><a href="#1-NSOperation的创建" class="headerlink" title="1.NSOperation的创建"></a>1.NSOperation的创建</h6><p>NSOperation是个抽象类，并不具备封装操作的能力，必须使用它的子类<br>使用NSOperation子类的方式有3种</p>
<p><strong>NSInvocationOperation</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一个参数:目标对象</span></span><br><span class="line"><span class="comment">  第二个参数:选择器,要调用的方法</span></span><br><span class="line"><span class="comment">  第三个参数:方法要传递的参数</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="built_in">NSInvocationOperation</span> *op  = [[<span class="built_in">NSInvocationOperation</span> alloc]initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(download) object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">//启动操作</span></span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>
<p><strong>NSBlockOperation（最常用）</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.封装操作</span></span><br><span class="line"><span class="built_in">NSBlockOperation</span> *op = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">    <span class="comment">//要执行的操作，在主线程中执行</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"1------%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//2.追加操作，追加的操作在子线程中执行，可以追加多条操作</span></span><br><span class="line">[op addExecutionBlock:^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download2--%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;];</span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>
<p><strong>自定义子类继承NSOperation，实现内部相应的方法</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写自定义类的main方法实现封装操作</span></span><br><span class="line">-(<span class="keyword">void</span>)main</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">// 要执行的操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个自定义对象，并执行操作</span></span><br><span class="line"><span class="built_in">CLOperation</span> *op = [[<span class="built_in">CLOperation</span> alloc]init];</span><br><span class="line">[op start];</span><br></pre></td></tr></table></figure>
<p>自定义类封装性高，复用性高。</p>
<h6 id="2-NSOperationQueue的使用"><a href="#2-NSOperationQueue的使用" class="headerlink" title="2.NSOperationQueue的使用"></a>2.NSOperationQueue的使用</h6><p>主队列：通过mainQueue获得，凡是放到主队列中的任务都将在主线程执行<br>非主队列：直接alloc init出来的队列。非主队列同时具备了并发和串行的功能，通过设置最大并发数属性来控制任务是并发执行还是串行执行<br>NSOperationQueue的作用<br>NSOperation可以调用start方法来执行任务，但默认是同步执行的<br>如果将NSOperation添加到NSOperationQueue（操作队列）中，系统会自动异步执行NSOperation中的操作</p>
<p>添加操作到NSOperationQueue中<br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addOperation:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line">- (<span class="keyword">void</span>)addOperationWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure></p>
<p>注意：将操作添加到NSOperationQueue中，就会自动启动，不需要再自己启动了addOperation 内部调用 start方法<br>start方法 内部调用 main方法</p>
<h6 id="3-NSOperation和NSOperationQueue结合使用创建多线程"><a href="#3-NSOperation和NSOperationQueue结合使用创建多线程" class="headerlink" title="3.NSOperation和NSOperationQueue结合使用创建多线程"></a>3.NSOperation和NSOperationQueue结合使用创建多线程</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">注：这里使用<span class="built_in">NSBlockOperation</span>示例，其他两种方法一样</span><br><span class="line">    <span class="comment">// 1. 创建非主队列 同时具备并发和串行的功能，默认是并发队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue =[[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="comment">//NSBlockOperation 不论封装操作还是追加操作都是异步并发执行</span></span><br><span class="line">    <span class="comment">// 2. 封装操作</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *op1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"download1 -- %@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 3. 将封装操作加入主队列</span></span><br><span class="line">    <span class="comment">// 也可以不获取封装操作对象 直接添加操作到队列中</span></span><br><span class="line">    <span class="comment">//[queue addOperationWithBlock:^&#123;</span></span><br><span class="line">    <span class="comment">// 操作</span></span><br><span class="line">    <span class="comment">//&#125;];</span></span><br><span class="line">    [queue addOperation:op1</span><br></pre></td></tr></table></figure>
<h6 id="4-NSOperation和NSOperationQueue的重要属性和方法"><a href="#4-NSOperation和NSOperationQueue的重要属性和方法" class="headerlink" title="4.NSOperation和NSOperationQueue的重要属性和方法"></a>4.NSOperation和NSOperationQueue的重要属性和方法</h6><p><strong>NSOperation</strong><br>NSOperation的依赖 – (void)addDependency:(NSOperation *)op;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 操作op1依赖op5，即op1必须等op5执行完毕之后才会执行</span></span><br><span class="line"><span class="comment">// 添加操作依赖,注意不能循环依赖，如果循环依赖会造成两个任务都不会执行</span></span><br><span class="line"><span class="comment">// 也可以夸队列依赖，依赖别的队列的操作</span></span><br><span class="line"> [op1 addDependency:op5];</span><br></pre></td></tr></table></figure>
<p>NSOperation操作监听void (^completionBlock)(void)</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听操作的完成</span></span><br><span class="line"><span class="comment">// 当op1线程完成之后，立刻就会执行block块中的代码</span></span><br><span class="line"><span class="comment">// block中的代码与op1不一定在一个线程中执行，但是一定在子线程中执行</span></span><br><span class="line">op1.completionBlock = ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"op1已经完成了---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p><strong>NSOperationQueue</strong></p>
<p>maxConcurrentOperationCount</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.创建队列</span></span><br><span class="line"> <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  默认是并发队列,如果最大并发数&gt;1,并发</span></span><br><span class="line"><span class="comment">  如果最大并发数==1,串行队列</span></span><br><span class="line"><span class="comment">  系统的默认是最大并发数-1 ,表示不限制</span></span><br><span class="line"><span class="comment">  设置成0则不会执行任何操作</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  queue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>suspended</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当值为YES的时候暂停,为NO的时候是恢复</span></span><br><span class="line">queue.suspended = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p>-(void)cancelAllOperations;</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//取消所有的任务，不再执行，不可逆</span></span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure>
<p>注意：暂停和取消只能暂停或取消处于等待状态的任务，不能暂停或取消正在执行中的任务，必须等正在执行的任务执行完毕之后才会暂停，如果想要暂停或者取消正在执行的任务，可以在每个任务之间即每当执行完一段耗时操作之后，判断是否任务是否被取消或者暂停。如果想要精确的控制，则需要将判断代码放在任务之中，但是不建议这么做，频繁的判断会消耗太多时间</p>
<h6 id="5-NSOperation和NSOperationQueue的一些其他属性和方法"><a href="#5-NSOperation和NSOperationQueue的一些其他属性和方法" class="headerlink" title="5.NSOperation和NSOperationQueue的一些其他属性和方法"></a>5.NSOperation和NSOperationQueue的一些其他属性和方法</h6><p><strong>NSOperation</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启线程</span></span><br><span class="line">- (<span class="keyword">void</span>)start;</span><br><span class="line">- (<span class="keyword">void</span>)main;</span><br><span class="line"><span class="comment">// 判断线程是否被取消</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isCancelled) <span class="built_in">BOOL</span> cancelled;</span><br><span class="line"><span class="comment">// 取消当前线程</span></span><br><span class="line">- (<span class="keyword">void</span>)cancel;</span><br><span class="line"><span class="comment">//NSOperation任务是否在运行</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isExecuting) <span class="built_in">BOOL</span> executing;</span><br><span class="line"><span class="comment">//NSOperation任务是否已结束</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFinished) <span class="built_in">BOOL</span> finished;</span><br><span class="line"><span class="comment">// 添加依赖</span></span><br><span class="line">- (<span class="keyword">void</span>)addDependency:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line"><span class="comment">// 移除依赖</span></span><br><span class="line">- (<span class="keyword">void</span>)removeDependency:(<span class="built_in">NSOperation</span> *)op;</span><br><span class="line"><span class="comment">// 优先级</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, <span class="built_in">NSOperationQueuePriority</span>) &#123;</span><br><span class="line">    <span class="built_in">NSOperationQueuePriorityVeryLow</span> = <span class="number">-8</span>L,</span><br><span class="line">    <span class="built_in">NSOperationQueuePriorityLow</span> = <span class="number">-4</span>L,</span><br><span class="line">    <span class="built_in">NSOperationQueuePriorityNormal</span> = <span class="number">0</span>,</span><br><span class="line">    <span class="built_in">NSOperationQueuePriorityHigh</span> = <span class="number">4</span>,</span><br><span class="line">    <span class="built_in">NSOperationQueuePriorityVeryHigh</span> = <span class="number">8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 操作监听</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^completionBlock)(<span class="keyword">void</span>) <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"><span class="comment">// 阻塞当前线程，直到该NSOperation结束。可用于线程执行顺序的同步</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilFinished <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"><span class="comment">// 获取线程的优先级</span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">double</span> threadPriority <span class="built_in">NS_DEPRECATED</span>(<span class="number">10</span>_6, <span class="number">10</span>_10, <span class="number">4</span>_0, <span class="number">8</span>_0);</span><br><span class="line"><span class="comment">// 线程名称</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_10, <span class="number">8</span>_0);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p><strong>NSOperationQueue</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取队列中的操作</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">NSOperation</span> *&gt; *operations;</span><br><span class="line"><span class="comment">// 队列中的操作数</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> operationCount <span class="built_in">NS_AVAILABLE</span>(<span class="number">10</span>_6, <span class="number">4</span>_0);</span><br><span class="line"><span class="comment">// 最大并发数，同一时间最多只能执行三个操作</span></span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">NSInteger</span> maxConcurrentOperationCount;</span><br><span class="line"><span class="comment">// 暂停 YES:暂停 NO:继续</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isSuspended) <span class="built_in">BOOL</span> suspended;</span><br><span class="line"><span class="comment">// 取消所有操作</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelAllOperations;</span><br><span class="line"><span class="comment">// 阻塞当前线程直到此队列中的所有任务执行完毕</span></span><br><span class="line">- (<span class="keyword">void</span>)waitUntilAllOperationsAreFinished;</span><br></pre></td></tr></table></figure>
<h6 id="6-NSOperation线程之间的通信"><a href="#6-NSOperation线程之间的通信" class="headerlink" title="6.NSOperation线程之间的通信"></a>6.NSOperation线程之间的通信</h6><p>NSOperation线程之间的通信方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回到主线程刷新UI</span></span><br><span class="line">[[<span class="built_in">NSOperationQueue</span> mainQueue]addOperationWithBlock:^&#123;</span><br><span class="line">      <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>我们同样使用下载多张图片合成综合案例</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIImage</span> *image1;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>)<span class="built_in">UIImage</span> *image2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建非住队列</span></span><br><span class="line">    <span class="built_in">NSOperationQueue</span> *queue = [[<span class="built_in">NSOperationQueue</span> alloc]init];</span><br><span class="line">    <span class="comment">// 下载第一张图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download1 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img2.3lian.com/2014/c7/12/d/77.jpg"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="keyword">self</span>.image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 下载第二张图片</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *download2 = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img2.3lian.com/2014/c7/12/d/77.jpg"</span>];</span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="keyword">self</span>.image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 合成操作</span></span><br><span class="line">    <span class="built_in">NSBlockOperation</span> *combie = [<span class="built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;</span><br><span class="line">        <span class="comment">// 开启图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">375</span>, <span class="number">667</span>));</span><br><span class="line">        <span class="comment">// 绘制图片1</span></span><br><span class="line">        [<span class="keyword">self</span>.image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">375</span>, <span class="number">333</span>)];</span><br><span class="line">        <span class="comment">// 绘制图片2</span></span><br><span class="line">        [<span class="keyword">self</span>.image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">334</span>, <span class="number">375</span>, <span class="number">333</span>)];</span><br><span class="line">        <span class="comment">// 获取合成图片</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">        <span class="comment">// 关闭图形上下文</span></span><br><span class="line">        <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">        <span class="comment">// 回到主线程刷新UI</span></span><br><span class="line">        [[<span class="built_in">NSOperationQueue</span> mainQueue]addOperationWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 添加依赖，合成图片需要等图片1，图片2都下载完毕之后合成</span></span><br><span class="line">    [combie addDependency:download1];</span><br><span class="line">    [combie addDependency:download2];</span><br><span class="line">    <span class="comment">// 添加操作到队列</span></span><br><span class="line">    [queue addOperation:download1];</span><br><span class="line">    [queue addOperation:download2];</span><br><span class="line">    [queue addOperation:combie];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h4 id="三、GCD的实现"><a href="#三、GCD的实现" class="headerlink" title="三、GCD的实现"></a>三、GCD的实现</h4><h6 id="1-任务和队列"><a href="#1-任务和队列" class="headerlink" title="1.任务和队列"></a>1.任务和队列</h6><p>GCD中有2个核心概念：任务和队列<br>任务：执行什么操作，任务有两种执行方式： 同步函数 和 异步函数，他们之间的区别是<br>同步：只能在当前线程中执行任务，不具备开启新线程的能力，任务立刻马上执行，会阻塞当前线程并等待 Block中的任务执行完毕，然后当前线程才会继续往下运行</p>
<p>异步：可以在新的线程中执行任务，具备开启新线程的能力，但不一定会开新线程，当前线程会直接往下执行，不会阻塞当前线程</p>
<p>队列：用来存放任务，分为串行队列 和 并行队列<br>串行队列（Serial Dispatch Queue）<br>让任务一个接着一个地执行（一个任务执行完毕后，再执行下一个任务）<br>并发队列（Concurrent Dispatch Queue）<br>可以让多个任务并发（同时）执行（自动开启多个线程同时执行任务）<br>并发功能只有在异步（dispatch_async）函数下才有效</p>
<p>GCD默认提供三种队列</p>
<ul>
<li><strong>main queue</strong></li>
<li><strong>global queue</strong></li>
<li><strong>dispatch_queue_t </strong></li>
</ul>
<h6 id="2-GCD的创建"><a href="#2-GCD的创建" class="headerlink" title="2.GCD的创建"></a>2.GCD的创建</h6><p><strong>队列的创建</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个参数const char *label : C语言字符串，用来标识</span></span><br><span class="line"><span class="comment">// 第二个参数dispatch_queue_attr_t attr : 队列的类型</span></span><br><span class="line"><span class="comment">// 并发队列:DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment">// 串行队列:DISPATCH_QUEUE_SERIAL 或者 NULL</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="keyword">const</span> <span class="keyword">char</span> *label, dispatch_queue_attr_t attr);</span><br></pre></td></tr></table></figure>
<p>创建并发队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.xxcc"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<p>创建串行队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.xxcc"</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
<p>GCD默认已经提供了全局并发队列，供整个应用使用，可以无需手动创建</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 第一个参数:优先级 也可直接填后面的数字</span></span><br><span class="line"><span class="comment"> #define DISPATCH_QUEUE_PRIORITY_HIGH 2 // 高</span></span><br><span class="line"><span class="comment"> #define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 // 默认</span></span><br><span class="line"><span class="comment"> #define DISPATCH_QUEUE_PRIORITY_LOW (-2) // 低</span></span><br><span class="line"><span class="comment"> #define DISPATCH_QUEUE_PRIORITY_BACKGROUND INT16_MIN // 后台</span></span><br><span class="line"><span class="comment"> 第二个参数: 预留参数  0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> quque1 =  dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>获得主队列</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span>  queue = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
<p><strong>任务的执行</strong></p>
<p>队列在queue中，任务在block块中<br>开启同步函数 同步函数：要求立刻马上开始执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一个参数:队列</span></span><br><span class="line"><span class="comment"> 第二个参数:block,在里面封装任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>开启异步函数 异步函数 ：等主线程执行完毕之后，回过头开线程执行任务</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>任务和队列的组合</strong></p>
<p>任务：同步函数 异步函数<br>队列：串行 并行<br>异步函数+并发队列：会开启新的线程,并发执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>异步函数+串行队列：会开启一条线程,任务串行执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_queue_create(<span class="string">"com.xxcc"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同步函数+并发队列：不会开线程,任务串行执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>同步函数+串行队列：不会开线程,任务串行执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_queue_create(<span class="string">"com.xxcc"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>异步函数+主队列:不会开线程,任务串行执行<br>使用主队列（跟主线程相关联的队列）<br>主队列是GCD自带的一种特殊的串行队列，放在主队列中的任务，都会放到主线程中执行</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获得主队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_get_main_queue();</span><br><span class="line"><span class="comment">//2.异步函数</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>同步函数+主队列:死锁</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.获得主队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue =  dispatch_get_main_queue();</span><br><span class="line"><span class="comment">//2.同步函数</span></span><br><span class="line"><span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">因为这个方法在主线程中，给主线程中添加任务，而同步函数要求立刻马上执行，因此就会相互等待而发生死锁。将这个方法放入子线程中，则不会发生死锁，任务串行执行。</span><br></pre></td></tr></table></figure>
<p><strong>同步函数和异步函数的执行顺序</strong></p>
<p>同步函数：立刻马上执行，会阻塞当前线程</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line"> [<span class="keyword">self</span> syncConcurrent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同步函数+并发队列:不会开线程,任务串行执行</span></span><br><span class="line">-(<span class="keyword">void</span>)syncConcurrent</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"--syncConcurrent--start-"</span>);</span><br><span class="line"> <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_sync</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"--syncConcurrent--end-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步函数：当前线程会直接往下执行，不会阻塞当前线程</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">   [<span class="keyword">self</span> syncConcurrent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//异步函数+并发队列:会开启新的线程,并发执行</span></span><br><span class="line">-(<span class="keyword">void</span>)asyncCONCURRENT</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">NSLog</span>(<span class="string">@"--asyncCONCURRENT--start-"</span>);</span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download1---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download2---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download3---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"---download4---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line"> &#125;);</span><br><span class="line">   <span class="built_in">NSLog</span>(<span class="string">@"--asyncCONCURRENT--end-"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="3-GCD线程间的通信"><a href="#3-GCD线程间的通信" class="headerlink" title="3.GCD线程间的通信"></a>3.GCD线程间的通信</h6><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line"></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">        <span class="comment">// 获得图片URL</span></span><br><span class="line">        <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://upload-images.jianshu.io/upload_images/2301429-d5cc0a007447e469.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"</span>];</span><br><span class="line">        <span class="comment">// 将图片URL下载为二进制文件</span></span><br><span class="line">        <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">        <span class="comment">// 将二进制文件转化为image</span></span><br><span class="line">        <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        <span class="comment">// 返回主线程 这里用同步函数不会发生死锁，因为这个方法在子线程中被调用。</span></span><br><span class="line">        <span class="comment">// 也可以使用异步函数</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>GCD线程间的通信非常简单，使用同步或异步函数，传入主队列即可。</p>
<h6 id="4-GCD其他常用函数"><a href="#4-GCD其他常用函数" class="headerlink" title="4.GCD其他常用函数"></a>4.GCD其他常用函数</h6><p><strong>栅栏函数dispatch_barrier_async</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"--dispatch_barrier_async-"</span>);</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>我们来看一下栅栏函数的作用</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">self</span> barrier];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)barrier</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//1.创建队列(并发队列)</span></span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">"com.xxccqueue"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%zd-download1--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%zd-download2--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//栅栏函数</span></span><br><span class="line"> dispatch_barrier_async(queue, ^&#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"我是一个栅栏函数"</span>);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%zd-download3--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%zd-download4--%@"</span>,i,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>栅栏函数可以控制任务执行的顺序，栅栏函数之前的执行完毕之后，执行栅栏函数，然后在执行栅栏函数之后的</p>
<p><strong>延迟执行</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 第一个参数:延迟时间</span></span><br><span class="line"><span class="comment"> 第二个参数:要执行的代码</span></span><br><span class="line"><span class="comment"> 如果想让延迟的代码在子线程中执行，也可以更改在哪个队列中执行 dispatch_get_main_queue() -&gt; dispatch_get_global_queue(0, 0)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2.0</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"---%@"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>延迟执行的其他方法：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2s中之后调用run方法</span></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(run) withObject:<span class="literal">nil</span> afterDelay:<span class="number">2.0</span>];</span><br><span class="line"><span class="comment">// repeats：YES 是否重复</span></span><br><span class="line">[<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">2.0</span> target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(run) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p><strong>一次性代码</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">-(<span class="keyword">void</span>)once</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="comment">//整个程序运行过程中只会执行一次</span></span><br><span class="line">     <span class="comment">//onceToken用来记录该部分的代码是否被执行过</span></span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"-----"</span>);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>一次性代码主要应用在单例模式中，关于单例模式详解大家可以去看iOS-单例模式写一次就够了这里不在赘述。</p>
<p><strong>快速迭代dispatch_apply</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  第一个参数:迭代的次数</span></span><br><span class="line"><span class="comment">  第二个参数:在哪个队列中执行</span></span><br><span class="line"><span class="comment">  第三个参数:block要执行的任务</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">dispatch_apply(<span class="number">10</span>, queue, ^(size_t index) &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>快速迭代：开启多条线程，并发执行，相比于for循环在耗时操作中极大的提高效率和速度<br>该函数按指定的次数将指定的Block追加到指定的Dispatch Queue中，并等待全部处理执行结束。</p>
<p><strong>队列组dispatch_group</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建队列组</span></span><br><span class="line"> dispatch_group_t group = dispatch_group_create();</span><br><span class="line"> <span class="comment">// 创建并行队列</span></span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> <span class="comment">// 执行队列组任务</span></span><br><span class="line"> dispatch_group_async(group, queue, ^&#123;</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//队列组中的任务执行完毕之后，执行该函数</span></span><br><span class="line"> dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure>
<p>下面看一了实例使用group下载两张图片然后合成在一起</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"ViewController.h"</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ViewController</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIImageView</span> *imageView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span>  *image1; <span class="comment">/**&lt; 图片1 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span>  *image2; <span class="comment">/**&lt; 图片2 */</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">-(<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span>&lt;<span class="built_in">UITouch</span> *&gt; *)touches withEvent:(<span class="built_in">UIEvent</span> *)event</span><br><span class="line">&#123;</span><br><span class="line"> [<span class="keyword">self</span> group];</span><br><span class="line">&#125;</span><br><span class="line">-(<span class="keyword">void</span>)group</span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">//下载图片1</span></span><br><span class="line"> <span class="comment">//创建队列组</span></span><br><span class="line"> dispatch_group_t group =  dispatch_group_create();</span><br><span class="line"> <span class="comment">//1.开子线程下载图片</span></span><br><span class="line"> <span class="comment">//创建队列(并发)</span></span><br><span class="line"> <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"> dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">     <span class="comment">//1.获取url地址</span></span><br><span class="line">     <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://www.huabian.com/uploadfile/2015/0914/20150914014032274.jpg"</span>];</span><br><span class="line">     <span class="comment">//2.下载图片</span></span><br><span class="line">     <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">     <span class="comment">//3.把二进制数据转换成图片</span></span><br><span class="line">     <span class="keyword">self</span>.image1 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"1---%@"</span>,<span class="keyword">self</span>.image1);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//下载图片2</span></span><br><span class="line"> dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">     <span class="comment">//1.获取url地址</span></span><br><span class="line">     <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://img1.3lian.com/img2011/w12/1202/19/d/88.jpg"</span>];</span><br><span class="line">     <span class="comment">//2.下载图片</span></span><br><span class="line">     <span class="built_in">NSData</span> *data = [<span class="built_in">NSData</span> dataWithContentsOfURL:url];</span><br><span class="line">     <span class="comment">//3.把二进制数据转换成图片</span></span><br><span class="line">     <span class="keyword">self</span>.image2 = [<span class="built_in">UIImage</span> imageWithData:data];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@"2---%@"</span>,<span class="keyword">self</span>.image2);</span><br><span class="line"> &#125;);</span><br><span class="line"> <span class="comment">//合成，队列组执行完毕之后执行</span></span><br><span class="line"> dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">     <span class="comment">//开启图形上下文</span></span><br><span class="line">     <span class="built_in">UIGraphicsBeginImageContext</span>(<span class="built_in">CGSizeMake</span>(<span class="number">200</span>, <span class="number">200</span>));</span><br><span class="line">     <span class="comment">//画1</span></span><br><span class="line">     [<span class="keyword">self</span>.image1 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">     <span class="comment">//画2</span></span><br><span class="line">     [<span class="keyword">self</span>.image2 drawInRect:<span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="number">200</span>, <span class="number">100</span>)];</span><br><span class="line">     <span class="comment">//根据图形上下文拿到图片</span></span><br><span class="line">     <span class="built_in">UIImage</span> *image =  <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line">     <span class="comment">//关闭上下文</span></span><br><span class="line">     <span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line">     <span class="comment">//回到主线程刷新UI</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">         <span class="keyword">self</span>.imageView.image = image;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"%@--刷新UI"</span>,[<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于篇幅问题，文中有很多方法没有具体解释。后期会在其它文章中做具体说明。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://codecloud.net/17391.html" target="_blank" rel="noopener">iOS-多线程详解</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
        <tag>线程</tag>
        <tag>NSThread</tag>
        <tag>NSOperation</tag>
        <tag>GCD</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods的安装和使用</title>
    <url>/2016/11/07/CocoaPods-Use/</url>
    <content><![CDATA[<h2 id="CocoaPods简介"><a href="#CocoaPods简介" class="headerlink" title="CocoaPods简介"></a>CocoaPods简介</h2><p>在开发iOS项目时，经常会使用第三方开源库，手动引入流程复杂，并且库之间还存在依赖关系，更增加了手动管理的难度。开源库如果升级了，你也想用最新版本，还需要重新手动导入，这大大增加了工作量。但用了CocoaPods后，安装和升级都只是一句命令的事情，让你可以专于业务本身。<br>CocoaPods项目的源码在Github上管理。该项目开始于2011年8月12日，经过多年发展，现在已经成为iOS开发事实上的依赖管理标准工具。开发iOS项目不可避免地要使用第三方开源库，CocoaPods的出现使得我们可以节省设置和更新第三方开源库的时间。<br><a id="more"></a></p>
<h2 id="CocoaPods安装"><a href="#CocoaPods安装" class="headerlink" title="CocoaPods安装"></a>CocoaPods安装</h2><ul>
<li><strong>安装Ruby</strong></li>
</ul>
<p>CocoaPods基于Ruby语言开发而成，因此安装CocoaPods前需要安装Ruby环境。幸运的是Mac系统默认自带Ruby环境，如果没有请自行查找安装。检测是否安装Ruby：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gem -v</span></span><br></pre></td></tr></table></figure></p>
<p>gem是一个管理Ruby库和程序的标准包，它通过Ruby Gem源来查找、安装、升级和卸载软件包，非常的便捷。</p>
<ul>
<li><strong>更换gem源</strong></li>
</ul>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>gem sources --remove <span class="symbol">https:</span>/<span class="regexp">/rubygems.org/</span></span><br><span class="line"><span class="variable">$ </span>gem sources -a <span class="symbol">https:</span>/<span class="regexp">/ruby.taobao.org/</span></span><br></pre></td></tr></table></figure>
<p>更换之后查看时候更换成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gem sources -l</span></span><br></pre></td></tr></table></figure>
<p>如果是淘宝的镜像则代表安装成功</p>
<ul>
<li><strong>安装CocoaPods</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo gem install cocoapods</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pod setup</span></span><br></pre></td></tr></table></figure>
<p>pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。<br>安装完成后查看是否安装成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pod --version</span></span><br></pre></td></tr></table></figure>
<h2 id="CocoaPods使用"><a href="#CocoaPods使用" class="headerlink" title="CocoaPods使用"></a>CocoaPods使用</h2><ul>
<li><strong>创建Podfile</strong></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim Podfile</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>编辑Podfile</strong></li>
</ul>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line"><span class="keyword">platform</span> :ios, <span class="string">'9.3'</span></span><br><span class="line">use_frameworks!</span><br><span class="line"></span><br><span class="line">target <span class="string">'Test'</span> <span class="keyword">do</span></span><br><span class="line">pod <span class="string">'SDWebImage'</span>, <span class="string">'~&gt;3.7.6'</span></span><br><span class="line">pod <span class="string">'Masonry'</span>, <span class="string">'~&gt;1.0.0'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>platform 的意思是系统支持的最低版本<br>use_frameworks!不写也是可以的。不过最好写上</p>
<p>target是你的工程名</p>
<p>do开始  end结束</p>
<ul>
<li><strong>退出Podfile</strong></li>
</ul>
<p>先按ESC,然后执行</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><span class="line"><span class="symbol">:wq</span></span><br></pre></td></tr></table></figure>
<p>然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> <span class="string">"your project home"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> pod install</span></span><br></pre></td></tr></table></figure>
<p>其实Podfile也可以用文本编辑。感觉更方便点，编辑完注意保存就行了。<br>安装之后使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。<br>每次更改了 Podfile 文件，你需要重新执行一次pod update命令。<br>如果想要查找第三方库，可使用<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pod search 关键字</span></span><br></pre></td></tr></table></figure></p>
<h2 id="关于-Podfile-lock"><a href="#关于-Podfile-lock" class="headerlink" title="关于 Podfile.lock"></a>关于 Podfile.lock</h2><p>当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。</p>
<h2 id="不更新-podspec"><a href="#不更新-podspec" class="headerlink" title="不更新 podspec"></a>不更新 podspec</h2><p>CocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：<br><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ pod install --<span class="keyword">no</span>-repo-<span class="keyword">update</span></span><br><span class="line">$ pod <span class="keyword">update</span> --<span class="keyword">no</span>-repo-<span class="keyword">update</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.devtang.com/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/" target="_blank" rel="noopener">用CocoaPods做iOS程序的依赖管理</a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>CocoaPods</tag>
        <tag>pod update</tag>
        <tag>pod install</tag>
        <tag>pod setup</tag>
      </tags>
  </entry>
  <entry>
    <title>在不同电脑上进行Hexo写作与同步</title>
    <url>/2016/11/07/hexo-more-PC/</url>
    <content><![CDATA[<p>如果你有多台电脑，而且每台电脑你都有可能会写博客。那么这个时候就需要对Hexo进行版本控制了。<br>版本控制的主要目的是方便在不同的电脑维护Hexo及写作。这里利用github的分支来保存hexo框架的相关文件(hexo配置、md、主题等文件)到github page仓库。<br>这里假设已经在github上建好page仓库，也就是”yourname.github.io”名字的仓库，以及在自己电脑上已经搭建好git、hexo、nodejs环境<br><a id="more"></a></p>
<h2 id="新建Hexo分支"><a href="#新建Hexo分支" class="headerlink" title="新建Hexo分支"></a>新建Hexo分支</h2><p>page仓库的master分支用来存放网站文件的，这是GitHub Page的要求，所以只好新建分支来保存Hexo原始文件，在下图的输入框输入分支名并按回车即完成分支创建。<br><img src="/2016/11/07/hexo-more-PC/branch1.png"></p>
<h2 id="设置默认分支"><a href="#设置默认分支" class="headerlink" title="设置默认分支"></a>设置默认分支</h2><p>因为我们写博客更多的是更新这个分支，网站文件所在的master分支则由hexo d命令发布文章的时候进行推送，所以我们将hexo分支&gt;设置为默认分支，这样我们在新的电脑环境下git clone该仓库时，自动切到hexo`分支。按下图进行操作。<br><img src="/2016/11/07/hexo-more-PC/branch2.png"></p>
<h2 id="配置hexo-deploy参数"><a href="#配置hexo-deploy参数" class="headerlink" title="配置hexo deploy参数"></a>配置hexo deploy参数</h2><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">  <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>: <span class="attribute">https</span>:<span class="comment">//github.com/leroyli/leroyli.github.io.git</span></span><br><span class="line">  <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure>
<p>然后使用部署命令hexo g -d就会自动渲染Markdown文件生成静态文件并部署到yourname.github.io仓库的master分支上，这时再访问<a href="http://yourname.github.io" target="_blank" rel="noopener">http://yourname.github.io</a> 就可以看到博客页面了。<br>此时博客页面是部署保存了，但hexo配置、md、主题等文件还没有保存，在heox目录下使用以下命令将文件推送到hexo分支上</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git remote <span class="keyword">add</span><span class="bash"> origin https://github.com/yourname/yourname.github.io.git</span></span><br><span class="line"><span class="bash">git add .</span></span><br><span class="line"><span class="bash">git commit -m <span class="string">"提交描述"</span></span></span><br><span class="line"><span class="bash">git push origin hexo</span></span><br></pre></td></tr></table></figure>
<p>下面来说说不同环境下的操作</p>
<h2 id="已有环境"><a href="#已有环境" class="headerlink" title="已有环境"></a>已有环境</h2><p>如果在电脑上已经写过博客，那么可以在已有的工作目录下同步之前写的博客。<br>在你的仓库目录下右键’git bash shell’，起来bash命令行，然后</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">git pull</span></span><br></pre></td></tr></table></figure>
<p>这样你的状态就更新了，之后就是 hexo命令写文章啦。。。<br>写完hexo g -d部署好后，使用</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br><span class="line"><span class="bash">git commit -m “change description”</span></span><br><span class="line"><span class="bash">git push origin hexo</span></span><br></pre></td></tr></table></figure>
<p>推送上去.</p>
<h2 id="新环境"><a href="#新环境" class="headerlink" title="新环境"></a>新环境</h2><p>到了新的电脑上时，我们需要将项目先下载到本地，然后再进行hexo初始化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/yourname/yourname.github.io.git</span><br><span class="line">cd yourname.github.io</span><br><span class="line">npm <span class="keyword">install</span> hexo</span><br><span class="line">npm <span class="keyword">install</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git –<span class="keyword">save</span></span><br></pre></td></tr></table></figure>
<p>之后开始写博客，写好部署好之后，别忘记 git add , ….git push origin hexo…推上去</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.rvclient.com/2016/05/21/hexo-everywhere/" target="_blank" rel="noopener">在不同的电脑维护Hexo和写作</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>多PC</tag>
        <tag>不同PC</tag>
        <tag>Hexo同步</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo+GitHub Pages搭建个人博客</title>
    <url>/2016/11/07/Hexo-GitHub-Pages/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直都很想搭建一个属于自己的个人博客，但是一直又没有时间。有时候自己写的东西或者做的总结只能随便找个地方就存起来，但是找的时候比较麻烦。正好最近时间比较充裕，所以就开始行动起来。有些人会觉得搭建个人博客会比较麻烦，其实当你真正做起来的时候你会发现并没有那么难。常言道：好记性不如烂笔头。所以我把我搭建博客的过程在此分享，希望能够帮助到那些想要搭建自己的博客但是还没有行动的小伙伴。</p>
<p>Hexo+Github Pages是目前比较流行的免费个人博客搭建方式，当然你也可以绑定域名。关于Hexo的来历我就不再赘述了。下面就来说说搭建流程。<br><a id="more"></a></p>
<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>1.Node.js<br>因为Hexo是一个基于Node.js的静态博客框架，因此需要先安装Node.js环境，下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a><br>2.Git<br>此处为Windows平台下的下载地址：<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a><br>或者可以选择直接下载:<a href="https://desktop.github.com/" target="_blank" rel="noopener">GitHub Desktop</a><br>Mac及其他操作系统请参考Hexo官方提供的下载链接。</p>
<h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>建议win用户在Git Bash中执行命令。<br>由于安装Hexo要用到npm，但是有时候速度很慢，如果速度过慢我们可以使用淘宝镜像<br><figure class="highlight coffeescript"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> install -g cnpm --registry=https:<span class="regexp">//</span>registry.<span class="built_in">npm</span>.taobao.org</span><br></pre></td></tr></table></figure></p>
<p>安装淘宝源之后只需要npm换成cnpm就行了。如<code>$ cnpm install hexo-cli -g</code><br>当然，如果你使用npm速度可以的话，那么安装淘宝源这一步你可以忽略。</p>
<p>完成以上环境配置之后，通过下面的命令安装Hexo<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-<span class="keyword">cli</span></span><br></pre></td></tr></table></figure></p>
<p>当出现</p>
<blockquote>
<p>Start blogging with Hexo !</p>
</blockquote>
<p>的时候表示Hexo安装成功。</p>
<h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装完成之后，选择一个目录作为建站所需文件的存放路径，如我选择d:\hexo\blog，执行以下命令完成hexo的初始化：<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">hexo init d:<span class="symbol">\h</span>exo<span class="symbol">\b</span>log</span><br></pre></td></tr></table></figure></p>
<p>然后命令行进入该目录下<br><figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">cd d:<span class="symbol">\h</span>exo<span class="symbol">\b</span>log</span><br></pre></td></tr></table></figure></p>
<p>执行下面的命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包<br><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span></span><br></pre></td></tr></table></figure></p>
<p>新建完成之后，根目录文件夹下各个目录的含义，可以参考Hexo官网的解释：<a href="https://hexo.io/zh-cn/docs/setup.html" target="_blank" rel="noopener">目录信息</a></p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>在建站工具的根目录（如上d:\hexo\blog）下通过以下命令启动服务器，之后访问网址 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 即可看到我们刚刚建立的博客，Hexo会默认生成一个Hello World的博文。<br><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure></p>
<p>hexo s是hexo server的简写，效果是一样的。这样我们就已经可以在本地浏览我们自己的博客了。以后每次对博客进行修改，都可以先通过这种方式进行本地的预览，满意之后再部署到GitHub Pages上。</p>
<h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><ul>
<li><p>首先在你的GitHub上新建一个Repository，仓库名的固定写法为 your_user_name.github.io。<br>Repository新建完成之后，点击界面右侧的Settings，你将会打开这个库的setting页面，向下拖动，直到看见GitHub Pages 。</p>
<img src="/2016/11/07/Hexo-GitHub-Pages/pages.png" title="leroy organization">
<p>点击Automatic page generator，Github将会自动替你创建出一个gh-pages的页面。</p>
</li>
<li><p>配置SSH-Key，网上有很多方法可供大家参考，也可参考我的另一篇<a href="https://leroyli.github.io/2016/11/07/github-ssh-key/" target="_blank" rel="noopener">文章</a></p>
</li>
<li><p>修改根目录的网站配置文件_config.yml，搜索deploy字段，修改成如下所示的格式。</p>
</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https:<span class="comment">//hexo.io/docs/deployment.html</span></span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line"><span class="symbol">    type:</span> git</span><br><span class="line"><span class="symbol">    repo:</span> git@github.com:leroyli/leroyli.github.io.git</span><br><span class="line"><span class="symbol">    branch:</span> master</span><br></pre></td></tr></table></figure>
<p>其中，repo是我们刚刚建立的远程仓库，换成你自己的id，同时因为刚才配置了SSH-Key，所以必须是SSH形式的URL。值得注意的是，每一个: 后面都必须有一个空格，否则会引起错误。</p>
<ul>
<li>安装Git包，执行以下命令</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br></pre></td></tr></table></figure>
<ul>
<li>部署到GitHub上，执行以下的命令</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo d</span></span><br></pre></td></tr></table></figure>
<p>hexo d是hexo deploy的简写，你也可以执行后者，效果是一样的。有时候如果部署不成功的话可以试试<code>hexo d -g</code>命令。或者可以用先<code>hexo g</code>后<code>hexo d</code>的命令组合。以后每次在本地编辑完成之后直接使用<code>hexo d</code>或者<code>hexo d -g</code>就可以部署到Github了。</p>
<p>现在我们可以通过访问 <a href="http://leroyli.github.io/" target="_blank" rel="noopener">http://leroyli.github.io/</a> 来访问我们自己的博客了！如果你要访问自己的博客，将链接中的用户名换成自己的就行了。到此，我们的博客已经基本建立完成，下面要说说怎么使用。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Hexo常用命令</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hexo generate (hexo g) 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹</span><br><span class="line">hexo<span class="built_in"> server </span>(hexo s) 启动本地web服务，用于博客的预览</span><br><span class="line">hexo deploy (hexo d) 部署播客到远端（比如github, heroku等平台）</span><br></pre></td></tr></table></figure>
<p>先说说hexo命令常用简写和常用组合<br><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ hexo n == hexo new</span><br><span class="line">$ hexo g == hexo generate</span><br><span class="line">$ hexo s == hexo server</span><br><span class="line">$ hexo d == hexo deploy</span><br></pre></td></tr></table></figure></p>
<p>常用组合<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> hexo d -g <span class="comment">#生成部署</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> hexo s -g <span class="comment">#生成预览</span></span></span><br></pre></td></tr></table></figure></p>
<p>新建一篇博文可通过以下的命令</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">new</span> <span class="string">"name"</span></span><br></pre></td></tr></table></figure>
<p>其中name为博文的名字，建立完成之后，可以在./source/_posts文件夹下发现我们刚刚建立的 name.md文件。使用你熟悉的编辑器打开，便可以进行博文的撰写。博文支持MarkDown语法的编写，下面是一个示例文件的内容<br><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">name</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2016</span><span class="bullet">-04</span><span class="bullet">-06</span> <span class="number">10</span><span class="string">:34:21</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">开始</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">日志</span></span><br><span class="line"><span class="attr">categories:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">日志</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="string">我的第一篇博文。。。。。。</span></span><br></pre></td></tr></table></figure></p>
<p>博文写好之后，在每次发布之前，我们要先将写好的博客生成静态文件，执行以下命令</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">hexo <span class="keyword">generate</span></span><br></pre></td></tr></table></figure>
<p>之后生成的文件会放在./public目录下，这便是我们将要部署到GitHub上的全部内容。</p>
<p>静态文件生成之后，便可以部署到GitHub上</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo deploy</span></span><br></pre></td></tr></table></figure>
<p>再重新打开我们的博客 <a href="http://leroyli.github.io/" target="_blank" rel="noopener">http://leroyli.github.io/</a> 已经可以看到刚刚新加入的博文.</p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p>Hexo提供了丰富的主题可供我们选择和使用，在./themes目录下存放主题。刚才默认生成的博客用的就是默认的主题landscape。这里有在GitHub上Hexo所有的主题，可以访问<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">https://github.com/hexojs/hexo/wiki/Themes</a></p>
<ol>
<li>安装主题的命令</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">&lt;repository</span>&gt; themes/<span class="tag">&lt;theme-name&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>打开 _config.yml</li>
</ol>
<p>文件，修改theme关键字段，改为刚才下载的 theme-name.我自己用的主题是Next,如果你想使用next主题请参考以下步骤</p>
<h2 id="Next主题配置"><a href="#Next主题配置" class="headerlink" title="Next主题配置"></a>Next主题配置</h2><p>首先cd到博客根目录，然后执行<br><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/iissnan/hexo-theme-<span class="keyword">next</span> themes/<span class="keyword">next</span></span><br></pre></td></tr></table></figure></p>
<p>然后修改配置文件<br>修改站点配置文件_config.yml，找到以下部分<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: http://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: http://hexo.io/themes/</span></span></span><br><span class="line">theme: landscape</span><br></pre></td></tr></table></figure></p>
<p>修改为<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Extensions</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Plugins: http://hexo.io/plugins/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Themes: http://hexo.io/themes/</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> theme: landscape</span></span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<p>至此，NexT主题就安装好了，非常方便，在Hexo中切换主题只需修改站点配置文件中theme属性来配置，想换就换。<br>next主题有三种Scheme，你可以通过修改配置文件来修改。<br><figure class="highlight avrasm"><table><tr><td class="code"><pre><span class="line"><span class="meta"># Schemes</span></span><br><span class="line"><span class="symbol">scheme:</span> Mist  <span class="meta">#去掉默认的注释即可切换为Mist主题</span></span><br></pre></td></tr></table></figure></p>
<p>以上基本就完成了博客的搭建和配置了</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://dukecuichen.com/2016/04/08/%E5%9F%BA%E4%BA%8EHexo%E6%A1%86%E6%9E%B6-GitHub-Pages%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">基于Hexo框架+GitHub Pages搭建个人博客</a><br><a href="http://zhiho.github.io/2015/09/29/hexo-next/" target="_blank" rel="noopener">Hexo搭建GitHub博客（三）- NexT主题配置使用</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github Pages</tag>
        <tag>个人博客</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub配置SSH Key</title>
    <url>/2016/11/07/github-ssh-key/</url>
    <content><![CDATA[<h2 id="SSH-Key-介绍"><a href="#SSH-Key-介绍" class="headerlink" title="SSH Key 介绍"></a>SSH Key 介绍</h2><p>SSH提供了两种级别的安全验证<br>第一种级别是基于密码的安全验证，知道账号和密码，就可以登陆到远程主机。Team的开发工作中，就是使用这种方式登陆编译服务器，或者开发机器。因为是在内网中，这种级别的安全验证已经足够了。<br>第二种级别是基于Public-key cryptography (公开密匙加密）机制的安全验证.其优点在于无需共享的通用密钥，解密的私钥不发往任何用户。即使公钥在网上被截获，如果没有与其匹配的私钥，也无法解密，所截获的公钥是没有任何用处的。<br><a id="more"></a></p>
<h2 id="生成SSH-Key"><a href="#生成SSH-Key" class="headerlink" title="生成SSH Key"></a>生成SSH Key</h2><p>以下步骤都是要安装Git才能运行的。如果是mac用户，安装了xcode就会默认安装了Git。如果是win用户，请先安装Git，win环境安装有两种方式。一种是Git Bash，一种是Git Desktop。个人推荐使用Git Bash.因为Git Desktop是要在线下载安装的，速度很慢。</p>
<ol>
<li><p>设置username和email</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ git<span class="built_in"> config </span>--global user.name <span class="string">"Your Name"</span></span><br><span class="line">$ git<span class="built_in"> config </span>--global user.email <span class="string">"email@example.com"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建SSH Key</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-keygen -t rsa -C <span class="string">"youremail@example.com"</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可.<br>如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p>
<h2 id="添加秘钥到ssh-agent（可选）"><a href="#添加秘钥到ssh-agent（可选）" class="headerlink" title="添加秘钥到ssh-agent（可选）"></a>添加秘钥到ssh-agent（可选）</h2><p>确保 ssh-agent 是可用的。ssh-agent是一种控制用来保存公钥身份验证所使用的私钥的程序，其实ssh-agent就是一个密钥管理器，运行ssh-agent以后，使用ssh-add将私钥交给ssh-agent保管，其他程序需要身份验证的时候可以将验证申请交给ssh-agent来完成整个认证过程。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start the ssh-agent in the background</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"<span class="variable">$(ssh-agent -s)</span>"</span></span><br><span class="line">    Agent pid 59566</span><br></pre></td></tr></table></figure></p>
<p>添加生成的SSH Key到ssh-agent<br><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ ssh-<span class="keyword">add</span><span class="bash"> ~/.ssh/id_rsa</span></span><br></pre></td></tr></table></figure></p>
<h2 id="提交公钥"><a href="#提交公钥" class="headerlink" title="提交公钥"></a>提交公钥</h2><p>登陆GitHub，打开“Account settings”，“SSH Keys”页面：<br>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。<br>最后点“Add Key”，你就应该看到已经添加的Key。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>SSH Key</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS UIviewController控制器管理</title>
    <url>/2016/11/06/iOS-UIviewController/</url>
    <content><![CDATA[<p>在iOS 5.0以前，我们一般是这样使用UIViewController的：一个UIViewController的View可能有很多小的子view。这些子view很多时候被盖在最后，我们在最外层ViewController的viewDidLoad方法中，用addSubview增加了大量的子view。这些子view大多数不会一直处于界面上，只是在某些情况下才会出现。<br>在iOS 5.0及以后，iOS为UIViewController类添加了新的属性和方法：<br><a id="more"></a><br><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *childViewControllers</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addChildViewController:(<span class="built_in">UIViewController</span> *)childController</span><br><span class="line">- (<span class="keyword">void</span>)removeFromParentViewController</span><br><span class="line">- (<span class="keyword">void</span>)transitionFromViewController：：：：：：</span><br><span class="line">- (<span class="keyword">void</span>)willMoveToParentViewController:(<span class="built_in">UIViewController</span> *)parent</span><br><span class="line">- (<span class="keyword">void</span>)didMoveToParentViewController:(<span class="built_in">UIViewController</span> *)parent</span><br></pre></td></tr></table></figure></p>
<p>这样，就能够将一个页面中的UIViewController控制起来，而不是混乱的共用一个UIViewController.</p>
<p>下面就分别来说说这几个方法:</p>
<h2 id="addChildViewController"><a href="#addChildViewController" class="headerlink" title="addChildViewController"></a>addChildViewController</h2><p>向视图控制器容器中添加子视图控制器，当要添加的子视图控制器已经包含在视图控制器容器中，那么，相当于先从父视图控制器中删除，然后重新添加到父视图控制器中。</p>
<h2 id="removeFromParentViewController"><a href="#removeFromParentViewController" class="headerlink" title="removeFromParentViewController"></a>removeFromParentViewController</h2><p>从父视图控制器中删除</p>
<h2 id="transitionFromViewController"><a href="#transitionFromViewController" class="headerlink" title="transitionFromViewController"></a>transitionFromViewController</h2><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)transitionFromViewController:(<span class="built_in">UIViewController</span> *)fromViewController</span><br><span class="line">                    toViewController:(<span class="built_in">UIViewController</span> *)toViewController</span><br><span class="line">                            duration:(<span class="built_in">NSTimeInterval</span>)duration</span><br><span class="line">                             options:(<span class="built_in">UIViewAnimationOptions</span>)options</span><br><span class="line">                          animations:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))animations</span><br><span class="line">                          completion:(<span class="keyword">void</span> (^)(<span class="built_in">BOOL</span> finished))completion;</span><br></pre></td></tr></table></figure>
<p>交换两个子视图控制器的位置（由于添加的顺序不同，所以子试图控制器在父视图控制器中存在层次关系）<br>各个参数的作用:<br><strong>fromViewController：</strong>当前显示的子试图控制器，将被替换为非显示状态<br><strong>toViewController：</strong>将要显示的子视图控制器<br><strong>duration：</strong>交换动画持续的时间，单位秒<br><strong>options：</strong>动画的方式<br><strong>animations：</strong>动画Block<br><strong>completion：</strong>完成后执行的Block</p>
<h2 id="willMoveToParentViewController"><a href="#willMoveToParentViewController" class="headerlink" title="willMoveToParentViewController"></a>willMoveToParentViewController</h2><p>官方文档:(部分段落的引用会出现空隙，不过不影响阅读)</p>
<blockquote>
<p>Your view controller can override this method when it needs to know that it has been added to a container.<br>If you are implementing your own container view controller, it must call the willMoveToParentViewController: method of the child view controller before calling the removeFromParentViewController method, passing in a parent value of nil.<br>When your custom container calls the addChildViewController: method, it automatically calls the willMoveToParentViewController: method of the view controller to be added as a child before adding it.</p>
</blockquote>
<p>当一个视图控制器从视图控制器容器中被添加或者被删除之前，该方法被调用</p>
<ol>
<li>当我们向我们的视图控制器容器中调用removeFromParentViewController方法时，必须要先调用该方法，且parent参数为nil：<br>[将要删除的视图控制器 willMoveToParentViewController:nil];</li>
<li>当我们调用addChildViewController方法时，在添加子视图控制器之前将自动调用该方法。所以，就不需要我们显示调用了。</li>
</ol>
<h2 id="didMoveToParentViewController"><a href="#didMoveToParentViewController" class="headerlink" title="didMoveToParentViewController"></a>didMoveToParentViewController</h2><p>官方文档:</p>
<blockquote>
<p>Your view controller can override this method when it wants to react to being added to a container.<br>If you are implementing your own container view controller, it must call the didMoveToParentViewController: method of the child view controller after the transition to the new controller is complete or, if there is no transition, immediately after calling the addChildViewController: method.<br>The removeFromParentViewController method automatically calls the didMoveToParentViewController: method of the child view controller after it removes the child.</p>
</blockquote>
<p>当从一个视图控制容器中添加或者移除viewController后，该方法被调用。<br>当我们向我们的视图控制器容器（就是父视图控制器，它调用addChildViewController方法加入子视图控制器，它就成为了视图控制器的容器）中添加（或者删除）子视图控制器后，必须调用该方法，告诉iOS，已经完成添加（或删除）子控制器的操作。<br>removeFromParentViewController 方法会自动调用了该方法，所以，删除子控制器后，不需要在显示的调用该方法了</p>
<h2 id="willMoveToParentViewController和didMoveToParentViewController的调用"><a href="#willMoveToParentViewController和didMoveToParentViewController的调用" class="headerlink" title="willMoveToParentViewController和didMoveToParentViewController的调用"></a>willMoveToParentViewController和didMoveToParentViewController的调用</h2><p>对于这两个方法的调用，苹果有注释:</p>
<blockquote>
<p>These two methods are public for container subclasses to call when transitioning between child controllers. If they are overridden, the overrides should ensure to call the super. The parent argument in both of these methods is nil when a child is being removed from its parent; otherwise it is equal to the new parent view controller. addChildViewController: will call [child willMoveToParentViewController:self] before adding the child. However, it will not call didMoveToParentViewController:. It is expected that a container view controller subclass will make this call after a transition to the new child has completed or, in the case of no transition, immediately after the call to addChildViewController:.<br>Similarly removeFromParentViewController: does not call [self willMoveToParentViewController:nil] before removing the child. This is also the responsibilty of the container subclass. Container subclasses will typically define a method that transitions to a new child by first calling addChildViewController:, then executing a transition which will add the new child’s view into the view hierarchy of its parent, and finally will call didMoveToParentViewController:. Similarly, subclasses will typically define a method that removes a child in the reverse manner by first calling [child willMoveToParentViewController:nil].</p>
</blockquote>
<ul>
<li><p>这两个方法用在子试图控制器交换的时候调用！即调用transitionFromViewController 方法时会调用这两个方法。</p>
</li>
<li><p>当调用willMoveToParentViewController方法或didMoveToParentViewController方法时，要注意他们的参数使用：<br>当某个子视图控制器将从父视图控制器中删除时，parent参数为nil。<br>即：[将被删除的子试图控制器 willMoveToParentViewController:nil];<br>当某个子试图控制器将加入到父视图控制器时，parent参数为父视图控制器。<br>即：[将被加入的子视图控制器 didMoveToParentViewController:父视图控制器];</p>
</li>
<li><p>当调用[父视图控制器 addChildViewController:子视图控制器]时，默认调用[子视图控制器 willMoveToParentViewController:父视图控制器]。只需要在transitionFromViewController方法后，调用[子视图控制器 didMoveToParentViewController:父视图控制器];</p>
</li>
<li><p>当调用[子视图控制器 removeFromParentViewController]时，默认调用[子视图控制器 didMoveToParentViewController:父视图控制器]。只需要在transitionFromViewController方法之前调用：[子视图控制器 willMoveToParentViewController:nil].</p>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>willMoveToParentViewController</tag>
        <tag>didMoveToParentViewController</tag>
        <tag>UIViewController</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中UIview layout相关方法</title>
    <url>/2016/11/06/uiview-layout/</url>
    <content><![CDATA[<p>在使用UIview的时候，与之相关几个layout方法总是容易搞混，所以就总结一下<br>首先列出与layout相关的几个方法</p>
<ul>
<li><strong>layoutSubviews</strong></li>
<li><strong>setNeedsLayout</strong></li>
<li><strong>layoutIfNeeded</strong></li>
<li><strong>setNeedsDisplay</strong></li>
<li><strong>drawRect</strong></li>
<li><strong>sizeThatFits</strong></li>
<li><strong>sizeToFit</strong></li>
</ul>
<p>下面就来分别说说这几个方法<br><a id="more"></a></p>
<h2 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h2><p>layoutSubviews在以下情况下会被调用：</p>
<ol>
<li>init初始化不会触发layoutSubviews。</li>
<li>addSubview会触发layoutSubviews。</li>
<li>设置view的Frame会触发layoutSubviews，当然前提是frame的值设置前后发生了变化。</li>
<li>滚动一个UIScrollView会触发layoutSubviews。</li>
<li>旋转Screen会触发父UIView上的layoutSubviews事件。</li>
<li>改变一个UIView大小的时候也会触发父UIView上的layoutSubviews事件。</li>
<li>直接调用setLayoutSubviews。</li>
</ol>
<p>官方文档对这个方法的说明：</p>
<blockquote>
<p>You should override this method only if the autoresizing behaviors of the subviews do not offer the behavior you want.layoutSubviews</p>
</blockquote>
<p>意思就是当我们在某个类的内部调整子视图位置时，需要调用这个方法。</p>
<h2 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h2><p>标记为需要重新布局，不立即刷新，会默认调用layoutSubviews。</p>
<h2 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h2><p>如果，有需要刷新的标记，立即调用layoutSubviews进行布局</p>
<h2 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay"></a>setNeedsDisplay</h2><p>setNeedsDisplay会自动调用drawRect方法，这样可以拿到 UIGraphicsGetCurrentContext，就可以进行绘制了。</p>
<h2 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h2><p>drawRect在以下情况下会被调用：</p>
<ol>
<li>如果在UIView初始化时没有设置rect大小，将直接导致drawRect不被自动调用。drawRect调用是在Controller-&gt;loadView, Controller-&gt;viewDidLoad 两方法之后掉用的.所以不用担心在控制器中,这些View的drawRect就开始画了.这样可以在控制器中设置一些值给View(如果这些View draw的时候需要用到某些变量值).</li>
<li>该方法在调用sizeToFit后被调用，所以可以先调用sizeToFit计算出size。然后系统自动调用drawRect:方法。</li>
<li>通过设置contentMode属性值为UIViewContentModeRedraw。那么将在每次设置或更改frame的时候自动调用drawRect:。</li>
<li>直接调用setNeedsDisplay，或者setNeedsDisplayInRect:触发drawRect:，但是有个前提条件是rect不能为0。</li>
</ol>
<p>drawRect方法使用注意点：</p>
<ol>
<li>若使用UIView绘图，只能在drawRect：方法中获取相应的contextRef并绘图。如果在其他方法中获取将获取到一个invalidate的ref并且不能用于画图。drawRect：方法不能手动显示调用，必须通过调用setNeedsDisplay 或者 setNeedsDisplayInRect，让系统自动调该方法。</li>
<li>若使用CAlayer绘图，只能在drawInContext: 中（类似于drawRect）绘制，或者在delegate中的相应方法绘制。同样也是调用setNeedDisplay等间接调用以上方法</li>
<li>若要实时画图，不能使用gestureRecognizer，只能使用touchbegan等方法来掉用setNeedsDisplay实时刷新屏幕</li>
</ol>
<h2 id="sizeThatFits-And-sizeToFit"><a href="#sizeThatFits-And-sizeToFit" class="headerlink" title="sizeThatFits And sizeToFit"></a>sizeThatFits And sizeToFit</h2><p>sizeThatFits的官方说明:</p>
<blockquote>
<p>The default implementation of this method returns the existing size of the view. Subclasses can override this method to return a custom value based on the desired layout of any subviews. For example, a UISwitch object returns a fixed size value that represents the standard size of a switch view, and a UIImageView object returns the size of the image it is currently displaying.<br>This method does not resize the receiver.</p>
</blockquote>
<p>这个方法默认会返回view当前的尺寸，子类可以重写这个方法根据子视图的期望返回自定义的值。</p>
<p>sizeToFit的官方说明:</p>
<blockquote>
<p>Call this method when you want to resize the current view so that it uses the most appropriate amount of space. Specific UIKit views resize themselves according to their own internal needs. In some cases, if a view does not have a superview, it may size itself to the screen bounds. Thus, if you want a given view to size itself to its parent view, you should add it to the parent view before calling this method.<br>You should not override this method. If you want to change the default sizing information for your view, override the sizeThatFits: instead. That method performs any needed calculations and returns them to this method, which then makes the change.</p>
</blockquote>
<p>当你想调整当前view的尺寸的时候调用这个方法，view根据内部需要调整自己的尺寸。如果一个view没有父视图，它可能调整自己适应屏幕。如果你想调整一个有父视图的view的尺寸，你应该在当前view添加到父视图之前调用这个方法。<br>如果你想改变一个view的默认尺寸，你应该重写sizeThatFits。sizeThatFits会进行计算并把新的尺寸返回给你。</p>
<p>调用sizeToFit的时候，类似于系统会根据内容的帮我布局一个它认为最合适的大小。<br>我们一般在不方便手动布局的时候才调用sizeToFit方法</p>
<ol>
<li><p>navigationBar中对navigationItem的设置，（添加两个视图以上的控件到Item）</p>
</li>
<li><p>toolBar中的对UIBarButtonItem的设置（一般还要添加弹簧控件）</p>
</li>
<li><p>在tabBar中我们不能手动的添加的子控件，因为tabBar是根据控制器系统默认自动添加的tabBarItem。（系统可能也会自动调用了这个方法）</p>
</li>
<li><p>UILabel中添加文字，然后让调整label的大小来适应文字，我们也调用sizeToFit的方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>uiview</tag>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode工程中类文件变白色的解决办法</title>
    <url>/2016/11/06/xcode-white/</url>
    <content><![CDATA[<p>做iOS开发的对Xcode再熟悉不过了，不过Xcode有时候也会出现一些烦人的bug，本文主要讨论Xcode使用过程中有时候会出现点击某个类文件就变白色的情况，看起来非常难受，下面就来说说怎样让Xcode恢复本来的样子<br>文件变白色的时候是下面的这个样子<br><a id="more"></a><br><img src="/2016/11/06/xcode-white/white1.png" title="leroy organization"></p>
<p>这个时候我们只需要点击上方菜单栏中的任意一个图标切换一下，然后再切换回来就行了</p>
<img src="/2016/11/06/xcode-white/white2.png" title="leroy organization">
<p>点击上如中红色框中的任意一个图标进行切换，然后切换回来就行了</p>
<img src="/2016/11/06/xcode-white/white3.png" title="leroy organization">
<p>这样就能轻松的解决了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>iOS多工程依赖</title>
    <url>/2016/11/05/iOS-more-project/</url>
    <content><![CDATA[<p>软件开发过程中，设计模式很重要，从开发人员的角度来讲项目结构也很重要。如果项目结构足够清晰的话，对开发和维护都会有很大帮助。尤其是一些稍微复杂点的项目。<br>iOS开发中，如果项目过大的话，使用多工程依赖会使整个工程的结构更加清晰。本文主要讨论如何在iOS开发中添加多工程依赖。<br><a id="more"></a><br>首先，要创建一个workspace工程，我是创建了一个singleview工程然后引入cocoapods</p>
<img src="/2016/11/05/iOS-more-project/project1.png" title="leroy organization">
<p>然后新建一个静态库工程</p>
<img src="/2016/11/05/iOS-more-project/project2.png" title="leroy organization">
<p>注意：这个静态库工程与第一个工程分开创建</p>
<img src="/2016/11/05/iOS-more-project/project3.png" title="leroy organization">
<p>BASE是基础工程，CommonUI是静态库工程</p>
<p>下一步CommonUI拖进基础工程的文件夹</p>
<img src="/2016/11/05/iOS-more-project/project4.png" title="leroy organization">
<p>接着打开基础工程，Add Files to…，把CommonUI引入</p>
<img src="/2016/11/05/iOS-more-project/project5.png" title="leroy organization">
<img src="/2016/11/05/iOS-more-project/project6.png" title="leroy organization">
<p>接下来是引入.a文件</p>
<img src="/2016/11/05/iOS-more-project/project7.png" title="leroy organization">
<p>然后是设置Header Path</p>
<img src="/2016/11/05/iOS-more-project/project8.png" title="leroy organization">
<p>再设置一下CommonUI的Header Path</p>
<img src="/2016/11/05/iOS-more-project/project9.png" title="leroy organization">
<p>最后为了保证编译顺序最好做如下设置</p>
<img src="/2016/11/05/iOS-more-project/project10.png" title="leroy organization">
<p>完成，现在就可以在BASE工程中导入CommonUI的头文件了，如果Xcode不提示直接强打就行了。<br>最后一步我是从别的帖子上看的，目前还不是很明白，如果有对着一块儿熟悉的，欢迎给出宝贵意见。写的不好，请大家见谅。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>依赖</tag>
        <tag>多工程</tag>
      </tags>
  </entry>
  <entry>
    <title>Xcode全局断点的设置</title>
    <url>/2016/11/05/Xcode-global-point/</url>
    <content><![CDATA[<p>在iOS开发过程中断点调试是必不可少的，有的时候局部的断点就可以满足需求。但是如果局部断点无法满足我们的需求时我们就会需要全局断点了，全局断点在调试过程中很实用，尤其是针对一些无法定位的crash。<br>设置全局断点其实很简单，步骤如下：</p>
<p>首先进入到断点设置</p>
<a id="more"></a>
<img src="/2016/11/05/Xcode-global-point/xcode1.png" title="leroy organization">
<p>然后点击<strong>+</strong>选择 <code>Add Symbolic Breakpoint</code></p>
<img src="/2016/11/05/Xcode-global-point/xcode2.png" title="leroy organization">
<p>在弹出的视图中输入 <code>-[NSException raise]</code></p>
<img src="/2016/11/05/Xcode-global-point/xcode3.png" title="leroy organization">
<p>然后敲回车，点击空白处就行了</p>
<p>然后再次重复上一步 <code>Add Symbolic Breakpoint</code></p>
<img src="/2016/11/05/Xcode-global-point/xcode4.png" title="leroy organization">
<p>在弹出的视图中输入 <code>objc_exception_throw</code><br>然后敲回车，点击空白处。</p>
<p>以上步骤就完成了全局断点的设置。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Xcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上ReactNative环境配置</title>
    <url>/2016/11/05/Mac-ReactNative/</url>
    <content><![CDATA[<p>React.js Conf 2015会议上，Facebook发布了React Native，可以基于目前大热的开源JavaScript库React.js来开发iOS和Android原生App。它的特点就是脱离传统Hybrid App的思路，基于HTML，CSS，JavaScript重新定义了一套规则。当然FaceBook也同时开源了Nuclide，它是一个针对ReactNative，web，以及原生移动开发的IDE。它基于跨平台文本编辑器Atom构建。<br>从ReactNative出现到现在，已经有越来越多的开发者或者公司开始试水，使用React Native开发者可以更高效的开发移动应用，ReactNative的诞生就是为了能在保持原生良好的交互体验的同时又极大的提高开发效率。像携程、天猫等都已经开始集成ReactNative。<br>要使用ReactNative，首先肯定是要搭建环境，下面就来说说怎样在Mac上搭建ReactNative环境。</p>
<p>全程基本都是在终端操作的：<br><a id="more"></a></p>
<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure>
<h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><p>其实Node是用Homebrew安装的，所以第一步成功才能进行第二步<br><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">brew install <span class="keyword">node</span><span class="title"></span></span><br></pre></td></tr></table></figure></p>
<h2 id="安装React-Native-Command-Line-Tools"><a href="#安装React-Native-Command-Line-Tools" class="headerlink" title="安装React Native Command Line Tools"></a>安装React Native Command Line Tools</h2><figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">npm</span> install -g react-<span class="keyword">native</span>-cli</span><br></pre></td></tr></table></figure>
<h2 id="安装Watchman"><a href="#安装Watchman" class="headerlink" title="安装Watchman"></a>安装Watchman</h2><p>如果你是针对iOS开发的，那么这一步之前最好保证你已经安装了Xcode7.0及7.0以上的版本<br><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>watchman</span><br></pre></td></tr></table></figure></p>
<h2 id="安装Flow"><a href="#安装Flow" class="headerlink" title="安装Flow"></a>安装Flow</h2><figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>flow</span><br></pre></td></tr></table></figure>
<p>至此环境配置就差不多了，剩下的就是创建一个基础的Demo工程了<br><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">react-<span class="keyword">native</span> init AwesomeProjectcd AwesomeProjectreact-<span class="keyword">native</span> run-ios</span><br></pre></td></tr></table></figure></p>
<p>上面这条指令是创建工程并在iOS模拟器上运行，当然你也可以找到工程文件找到里面的iOS文件夹找到Xcode工程运行。</p>
<p>以上内容参考自[ReactNative官网][1]<br>[1]:<a href="http://facebook.github.io/react-native/docs/getting-started.html" target="_blank" rel="noopener">http://facebook.github.io/react-native/docs/getting-started.html</a></p>
]]></content>
      <categories>
        <category>ReactNative</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>ReactNative</tag>
      </tags>
  </entry>
</search>
